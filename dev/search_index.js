var documenterSearchIndex = {"docs":
[{"location":"theory/","page":"Background","title":"Background","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"theory/","page":"Background","title":"Background","text":"This is a brief overview of the mathematics of geometric algebra, using GeometricAlgebra.jl to explain features along the way.","category":"page"},{"location":"theory/#Features-of-geometric-algebra","page":"Background","title":"Features of geometric algebra","text":"","category":"section"},{"location":"theory/","page":"Background","title":"Background","text":"Geometric algebra unifies many concepts in geometry, linear algebra and physics by offering an elegant language for geometric objects and the transformations on them. In particular, it","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"provides a uniform formalism for rotations in any number of dimensions;\nefficiently models Euclidean, projective, and conformal geometries;\nunifies the dot product  and wedge product  from exterior calculus into the same algebra, creating an invertible geometric product;\nconsists of elements with concrete geometric interpretations;\ngeneralises the complex numbers â„‚, quaternions â„, Pauli and Dirac matrix algebras and realises them as algebras over real vector spaces.","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"For more thorough introductions, see Stephen Gull, Anthony Lasenby, Chris Doran (1993).","category":"page"},{"location":"theory/#Abstract-definition","page":"Background","title":"Abstract definition","text":"","category":"section"},{"location":"theory/","page":"Background","title":"Background","text":"Geometric algebra is what you get when vectors in a space are allowed to be multiplied freely, subject to:","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"associativity, ğ’–(ğ’—ğ’˜) = (ğ’–ğ’—)ğ’˜; and\nthe condition that a vector ğ’– multiplied by itself is the dot product, ğ’–^2 = ğ’–ğ’–.","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"Notice that the ingredients for a geometric algebra are a vector space V and an inner product  on V.","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"details: Details\nFormally, the geometric algebra ğ’¢(V ) over a vector space V with the inner product  is the quotientğ’¢(V )  V^ big ğ’–  ğ’– - ğ’–ğ’– mid ğ’–  Vwhich the free tensor algebra V^ = â„  V  (V  V)   except elements of the form ğ’–  ğ’– - ğ’–ğ’– for ğ’–  V are set to zero.","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"All other features a geometric algebra follow from the definition, even if they are not obvious at first! If ğ’—_1  ğ’—_n  V are orthonormal basis vectors, then it turns out that in the geometric algebra ğ’¢(V ):","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"Elements are generally non-commutative. E.g., ğ’—_1ğ’—_2 = -ğ’—_2ğ’—_1.\nThere are more elements than just vectors in V: now there are multivectors of grades 0  n. E.g., ğ’—_1ğ’—_2 is a bivector.\nMultiplication can produce multivectors of mixed grade. E.g., if ğ’– = 2ğ’—_1 + ğ’—_2 is a vector, then ğ’–ğ’—_2 = 1 + 2ğ’—_1ğ’—_2 is a 0 2-multivector with scalar and bivector parts.\nMost elements are invertible. E.g., if ğ’– is the vector above, then ğ’–^-1 = frac25 ğ’—_1 + frac15 ğ’—_2 and ğ’–ğ’–^-1 = 1.\nOther products, including the wedge , can be defined in terms of the geometric product and grade projection. E.g., ğ’–ğ’—_2 = 2ğ’—_1ğ’—_2 takes the highest-grade part of the product ğ’–ğ’—_2 = 1 + 2ğ’—_1ğ’—_2.","category":"page"},{"location":"theory/#Terminology","page":"Background","title":"Terminology","text":"","category":"section"},{"location":"theory/","page":"Background","title":"Background","text":"Term Definition Example\nmultivector Any element of a geometric algebra 1 ğ’—_1 1 + ğ’—_1ğ’—_2\nk-vector A homogeneous multivector, containing only grade-k parts ğ’˜ = ğ’—_1ğ’—_2 + ğ’—_3ğ’—_4 is a 2-vector or bivector\nvector Usually refers to a 1-vector, even though every multivector is a â€œvectorâ€ in the linear algebra sense ğ’– = 2ğ’—_1 + ğ’—_2\nk-blade A k-vector which can be factored as a -product of k-many vectors ğ’–ğ’—_3 = 2ğ’—_1ğ’—_3 + ğ’—_2ğ’—_3 is a 2-blade, but ğ’˜ is not\nbasis blade A k-blade which is a scalar multiple of the product of orthonormal basis vectors 1 2ğ’—_1ğ’—_3 -ğ’—_1ğ’—_2ğ’—_3","category":"page"},{"location":"theory/#Example-in-â„3","page":"Background","title":"Example in â„^3","text":"","category":"section"},{"location":"theory/","page":"Background","title":"Background","text":"To see what the definition means, weâ€™ll look at the example of 3D space V = â„^3 with the usual Euclidean dot product: the 3D geometric algebra ğ’¢(â„^3 ) or ğ’¢(3).","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"We may get the standard orthonormal basis ğ’—_1 ğ’—_2 ğ’—_3  â„^n using","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"julia> v1, v2, v3 = basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n v1\n v2\n v3","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"From the definition ğ’–^2 = ğ’–ğ’–, we know how to multiply ğ’—_1 with itself:","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"julia> v1*v1\nBasisBlade{3, 0, Int64}:\n 1","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"<details>\n<summary>But what about <code>v1*v2</code>?</summary>","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"The relation ğ’–^2 = ğ’–ğ’– doesnâ€™t immediately say how to multiply two different vectors â€” but everything about geometric product follows from it. Notice that if we apply the relation to ğ’– + ğ’— instead of ğ’–, we find that","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"beginalign*\n\t(ğ’– + ğ’—)^2 = (ğ’– + ğ’—)(ğ’– + ğ’—)\n\tğ’–^2 + ğ’–ğ’— + ğ’—ğ’– + ğ’—^2 = ğ’–ğ’– + 2ğ’–ğ’— + ğ’—ğ’—\n\tğ’–ğ’— + ğ’—ğ’– = 2ğ’–ğ’—\nendalign*","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"In our case, ğ’—_1ğ’—_2 = 0 are orthogonal, so this means","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"ğ’—_1ğ’—_2 = -ğ’—_2ğ’—_1","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"which we can check with code:","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"</details><br>","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"julia> v1*v2\nBasisBlade{3, 2, Int64}:\n 1 v12\n\njulia> v2*v1\nBasisBlade{3, 2, Int64}:\n -1 v12","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"This is a new kind of object â€” they are grade-2 bivectors in 3D space:","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"julia> dimension(v1*v2), grade(v1*v2)\n(3, 2)","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"In fact, there are 2^3 = 8 different linearly independent objects in the geometric algebra ğ’¢(3):","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"julia> basis(3, grade=:all)\n8-element Vector{BasisBlade{3, _A, Int64} where _A}:\n 1\n v1\n v2\n v3\n v12\n v13\n v23\n v123","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"We can generate a complete multiplication table for ğ’¢(3):","category":"page"},{"location":"theory/","page":"Background","title":"Background","text":"julia> cayleytable(3)\n (â†“) * (â†’) â”‚    1 â”‚   v1     v2    v3 â”‚  v12    v13   v23 â”‚ v123\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n         1 â”‚    1 â”‚   v1     v2    v3 â”‚  v12    v13   v23 â”‚ v123\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n        v1 â”‚   v1 â”‚    1    v12   v13 â”‚   v2     v3  v123 â”‚  v23\n        v2 â”‚   v2 â”‚ -v12      1   v23 â”‚  -v1  -v123    v3 â”‚ -v13\n        v3 â”‚   v3 â”‚ -v13   -v23     1 â”‚ v123    -v1   -v2 â”‚  v12\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n       v12 â”‚  v12 â”‚  -v2     v1  v123 â”‚   -1   -v23   v13 â”‚  -v3\n       v13 â”‚  v13 â”‚  -v3  -v123    v1 â”‚  v23     -1  -v12 â”‚   v2\n       v23 â”‚  v23 â”‚ v123    -v3    v2 â”‚ -v13    v12    -1 â”‚  -v1\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n      v123 â”‚ v123 â”‚  v23   -v13   v12 â”‚  -v3     v2   -v1 â”‚   -1","category":"page"},{"location":"theory/#References","page":"Background","title":"References","text":"","category":"section"},{"location":"theory/","page":"Background","title":"Background","text":"","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"design/#Design-and-Internals","page":"Design and Internals","title":"Design and Internals","text":"","category":"section"},{"location":"design/#Multivector-Types","page":"Design and Internals","title":"Multivector Types","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"There are two concrete types for representing elements in a geometric algebra:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}    Multivector{Sig,K,S}","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"BasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Type parameters:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Sig: The metric signature which defines the geometric algebra. This can be any  all-bits value which satisfies the metric signature interface.\nK: The grade(s) of a multivector. For BasisBlades, this is an integer, but for Multivectors, it may be a collection (e.g., 0:3 for a general 3D multivector).\nT: The numerical type of the coefficient of a BasisBlade.\nS: The storage type of the components of a Multivector, usually an AbstractVector subtype.","category":"page"},{"location":"design/#Metric-Signatures","page":"Design and Internals","title":"Metric Signatures","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter Sig defines the dimension of the geometric algebra and the norms of its standard orthonormal basis vectors. Additionally, it allows various default behaviours to be customised through method definitions which dispatch on Sig, as detailed in the metric signature interface.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, the following metric signature types are implemented:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Int, defining a Euclidean metric of that dimension,\nTuple, defining the norms of each basis vector,\nNamedTuple, defining basis vector labels as well as norms,\nCl, a type resembling the notation Cl(p q r) common in literature.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> @basis 2\n[ Info: Defined basis blades v, v1, v2, v12\n\njulia> basis((t=-1, x=1, y=1, z=1)) |> prod\nBasisBlade{(t = -1, x = 1, y = 1, z = 1), 4, Int64}:\n 1 txyz\n","category":"page"},{"location":"design/#sig-interface","page":"Design and Internals","title":"The metric signature interface","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter may be any isbits value satisying the following interface. As well as defining the geometric algebra, the signature is used to specify basis blade labels, the default array type for multivector components, and other metadata.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Required methods Description\ndimension(sig) The dimension of the underlying vector space, or number of basis vectors.\nbasis_vector_norm(sig, i) The norm of the ith basis vector.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Optional methods Description\nshow_signature(io, sig) Show the metric signature in a compact human-readable form.\nshow_basis_blade(io, sig, indices) Print a basis blade with the given indices (e.g., v12 or ğ’†â‚âˆ§ğ’†â‚‚).\ncomponentstype(sig, N, T) Preferred array type for CompositeMultivector components. (Default is Vector{T} in low dimensions and SparseVector{T} otherwise.)\nuse_symbolic_optim(sig) Whether to use symbolic code generation to optimise multivector products. (Default is true for low dimensions.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Below is an example of how one might define a geometric algebra with specific behaviours:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"struct DiracGamma end\n\n# define the algebra\nGeometricAlgebra.dimension(::DiracGamma) = 4\nGeometricAlgebra.basis_vector_norm(::DiracGamma, i) = i > 1 ? -1 : +1\n\n# set the preferred component storage type (optional)\nusing StaticArrays\nGeometricAlgebra.componentstype(::DiracGamma, N, T) = MVector{N,T}\n\n# custom labels (optional)\nfunction GeometricAlgebra.show_basis_blade(io, ::DiracGamma, indices)\n\tprint(io, join(\"Î³\".*GeometricAlgebra.superscript.(indices .- 1)))\nend\n\nbasis(DiracGamma())\n# output\n4-element Vector{BasisBlade{DiracGamma(), 1, Int64}}:\n Î³â°\n Î³Â¹\n Î³Â²\n Î³Â³","category":"page"},{"location":"design/#Symbolic-Algebra-and-Code-Generation","page":"Design and Internals","title":"Symbolic Algebra and Code Generation","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Thanks to the wonderful SymbolicUtils package, the same code originally written for numerical multivectors readily works with symbolic components. For example, we can compute the product of two vectors symbolically as follows:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> GeometricAlgebra.symbolic_components.([:x, :y], 3)\n2-element Vector{Vector{Any}}:\n [x[1], x[2], x[3]]\n [y[1], y[2], y[3]]\n\njulia> Multivector{3,1}.(ans)\n2-element Vector{Multivector{3, 1, Vector{Any}}}:\n x[1]v1 + x[2]v2 + x[3]v3\n y[1]v1 + y[2]v2 + y[3]v3\n\njulia> prod(ans)\n4-component Multivector{3, 0:2:2, Vector{Any}}:\n x[1]*y[1] + x[2]*y[2] + x[3]*y[3]\n x[1]*y[2] - x[2]*y[1] v12 + x[1]*y[3] - x[3]*y[1] v13 + x[2]*y[3] - x[3]*y[2] v23\n","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"This makes it easy to optimize multivector operations by first performing the general calculation symbolically, then converting the resulting expression into unrolled code.  (See symbolic_multivector_eval() for details.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, symbolic code generation is used for most products in up to eight dimensions (above which general algebraic expressions become unwieldy). This can be changed on a per-algebra basis by defining methods for use_symbolic_optim().","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Multivector-Types","page":"Reference","title":"Multivector Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"types.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.AbstractMultivector","page":"Reference","title":"GeometricAlgebra.AbstractMultivector","text":"AbstractMultivector{Sig}\n\nSupertype of all elements in the geometric algebra defined by the metric signature Sig.\n\nSubtypes\n\n         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}   Multivector{Sig,K,S}                \n\nBasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.BasisBlade","page":"Reference","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig,K,T}\n\nA basis blade of grade K and scalar coefficient of type T.\n\nBasis blades are scalar multiples of wedge products of orthogonal basis vectors.\n\nnote: Note\nNot every k-blade (i.e., wedge product of k linearly independent vectors) is representable as a BasisBlade. However, every k-blade is a Multivector of grade k.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK::Int: Grade of the blade, equal to count_ones(bits), retrieved with grade().\nT: Numerical type of the scalar coefficient, retrieved with eltype().\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.BasisBlade-Union{Tuple{Pair}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig}(bits, coeff)\nBasisBlade{Sig}(bits => coeff)\n\nBasis blade with indices encoded by bits and scalar coefficient coeff.\n\nIndices are encoded in binary (e.g., vâ‚vâ‚ƒvâ‚„ has bits 0b1101).\n\nExamples\n\njulia> BasisBlade{3}(0b110 => 42) # a grade 2 blade in 3 dimensions\nBasisBlade{3, 2, Int64}:\n 42 v23\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.Multivector","page":"Reference","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K,S} <: AbstractMultivector{Sig}\n\nA general multivector with parts of grade âˆˆ K.\n\nFor homogeneous k-vectors, the grade parameter K is an integer. Inhomogeneous multivectors may be specified with a range or tuple of grades.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK: Grade(s) present in the multivector. Can be an integer or a collection of integers (a range or tuple).\nS: Storage type of the multivector components, usually a subtype of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.Multivector-Union{Tuple{S}, Tuple{K}, Tuple{Sig}} where {Sig, K, S}","page":"Reference","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K}(comps)\n\nMultivector with grade(s) K and component vector comps.\n\nComponents are ordered first by grade, then lexicographically by bits (see componentbits).\n\nExamples\n\njulia> Multivector{3,0:3}(1:2^3)\n8-component Multivector{3, 0:3, UnitRange{Int64}}:\n 1\n 2 v1 + 3 v2 + 4 v3\n 5 v12 + 6 v13 + 7 v23\n 8 v123\n\njulia> grade(ans, 1)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 2 v1\n 3 v2\n 4 v3\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentindex-Tuple{Any, BasisBlade}","page":"Reference","title":"GeometricAlgebra.componentindex","text":"componentindex(a::Multivector, b)\n\nIndex of components vector of a corresponding to the BasisBlade or bits b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.dimension-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.dimension","text":"dimension(sig)\ndimension(::AbstractMultivector)\n\nThe dimension of the underlying vector space of the geometric algebra. See ncomponents for the dimension of the algebra (i.e., the number of independent components of a general multivector).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.grade-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:(BasisBlade{Sig, K})}, Tuple{K}, Tuple{Sig}} where {Sig, K}","page":"Reference","title":"GeometricAlgebra.grade","text":"grade(a)\n\nGrade(s) of a multivector a.\n\nThe grade of a BasisBlade{Sig,K} or Multivector{Sig,K} is the second type parameter, K, which may be an integer (if a is homogeneous) or a collection (a range or tuple of grades).\n\nSee also ishomogeneous.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ishomogeneous-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.ishomogeneous","text":"ishomogeneous(a)\n\nWhether a is homogeneous, i.e., consists of nonzero parts of the same grade.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ncomponents-Tuple{Multivector}","page":"Reference","title":"GeometricAlgebra.ncomponents","text":"ncomponents(::CompositeMultivector)\n\nNumber of independent components of a multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.resulting_multivector_type-Union{Tuple{Sig}, Tuple{Any, Vararg{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}}} where Sig","page":"Reference","title":"GeometricAlgebra.resulting_multivector_type","text":"resulting_multivector_type(f, a, b, ...)\n\nReturn a Multivector{Sig,K,S} type with parameters (signature S, grade(s) K and storage type S) appropriate for representing the result of f(a, b).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.signature-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.signature","text":"signature(::AbstractMultivector{Sig}) = Sig\n\nThe metric signature type parameter of the multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Algebraic-Operations","page":"Reference","title":"Algebraic Operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"algebra.jl\", \"special.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#Base.:~-Tuple{AbstractMultivector}","page":"Reference","title":"Base.:~","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector a, the reversion is reversion_sign(k)*a where the sign is given by (-1)^k(k - 1)2.\n\nSee also involution and clifford_conj.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:'á¶œ-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.:'á¶œ","text":"a'á¶œ\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:âˆ§-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:âˆ§","text":"a âˆ§ b\nwedge(a, b)\n\nWedge product of multivectors, a.k.a. the outer, exterior or alternating product.\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a âˆ§ b is defined as the grade p + q part of a*b.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:âŠ™-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:âŠ™","text":"a âŠ™ b\nscalar_prod(a, b) -> Number\n\nScalar part of the multivector product a*b.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:â‹…-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:â‹…","text":"a â‹… b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(absâˆ˜-, a, b). If a and b are of grades p and q respectively, then a â‹… b is defined as the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see Leo Dorst (2002) for discussion).\n\nSee also lcontract and rcontract.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:â¨¼-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:â¨¼","text":"a â¨¼ b\nlcontract(a, b)\n\nLeft contraction of multivectors.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a â¨¼ b is defined as the grade q - p part of a*b.\n\nSee also rcontract and inner.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:â¨½-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:â¨½","text":"a â¨½ b\nrcontract(a, b)\n\nRight contraction of multivectors.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a â¨½ b is defined as the grade p - q part of a*b.\n\nSee also lcontract and inner.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.clifford_conj-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.clifford_conj","text":"a'á¶œ\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.flipdual","page":"Reference","title":"GeometricAlgebra.flipdual","text":"flipdual(a)\n\nA dual of a multivector, for when the overall sign isnâ€™t important.\n\nFor a unit basis blade a::BasisBlade, the flipdual satisfies a*flipdual(a) == Â±I where Â±I is the unit pseudoscalar or its negative.\n\nComputing the flipdual is cheap, and is its own inverse: for a BasisBlade, its bits are flipped, and for a CompositeMultivector, the components vector is simply reversed.\n\nThe flipdual is metric independent, but depends on a choice of basis. It differs from the Hodge and PoincarÃ© duals by a per-grade scalar factor. This makes it useful in projective geometry, where scalar factors are largely arbitrary.\n\nSee also hodgedual and poincaredual.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.geometric_prod-Tuple{Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.geometric_prod","text":"a * b\ngeometric_prod(a, b)\n\nGeometric product of multivectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.graded_multiply-Tuple{Any, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.graded_multiply","text":"graded_multiply(f, a::AbstractMultivector)\n\nMultiply the grade k part of a by f(k).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.graded_prod-Tuple{Any, Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.graded_prod","text":"graded_prod(grade_selector::Function, a, b)\n\nA \"graded\" product of multivectors, generalising the wedge , inner  and contraction products. For example, the wedge product is defined as:\n\nwedge(a, b) = graded_prod(+, a, b)\n\nIf grade(a) == p and grade(b) == q, then graded_prod(f, a, b) is the grade f(p, q) part of a*b. The definition extends linearly to general multivectors A and B as\n\n\t(A B)  sum_pq A_p B_q_f(p q)\n\nwhere _k denotes the grade k part.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.hodgedual","page":"Reference","title":"GeometricAlgebra.hodgedual","text":"hodgedual(a) = ~a*I\n\nHodge dual of a multivector.\n\nThe Hodge dual is given by\n\na = a I\n\nwhere a is the reversion of a and I is the unit pseudoscalar. For k-vectors a and b, it is alternatively defined by\n\na  b = a b I\n\nwhere a b = a  b is the induced inner product on k-vectors.\n\nThe Hodge dual depends on the metric and orientation (choice of pseudoscalar).\n\nSee also poincaredual.\n\nExamples\n\njulia> u = Multivector{3,1}(1:3)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 1 v1\n 2 v2\n 3 v3\n\njulia> hodgedual(u)\n3-component Multivector{3, 2, Vector{Int64}}:\n  3 v12\n -2 v13\n  1 v23\n\njulia> u âˆ§ hodgedual(u), u âŠ™ ~u\n(14v123, 14)\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.inner-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.inner","text":"a â‹… b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(absâˆ˜-, a, b). If a and b are of grades p and q respectively, then a â‹… b is defined as the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see Leo Dorst (2002) for discussion).\n\nSee also lcontract and rcontract.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.involution-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.involution","text":"involution(a)\n\nInvolute of a multivector.\n\nInvolution is an automorphism defined by reflecting through the origin: for homogeneous multivectors, involution(a) == (-1)^grade(a)*a.\n\nSee also reversion and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.lcontract-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.lcontract","text":"a â¨¼ b\nlcontract(a, b)\n\nLeft contraction of multivectors.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a â¨¼ b is defined as the grade q - p part of a*b.\n\nSee also rcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.poincaredual","page":"Reference","title":"GeometricAlgebra.poincaredual","text":"poincaredual(a)\n\nPoincarÃ© dual of a multivector.\n\nFor a unit basis blade a::BasisBlade, the PoincarÃ© dual satisfies a*poincaredual(a) == I where I is the unit pseudoscalar. I.e., poincaredual(a) is a â€œright complementâ€ of a.\n\nThe PoincarÃ© dual is metric independent, but depends on a choice of basis. This makes is useful in degenerate algebras: non-zero multivectors have non-zero PoincarÃ© duals, even if their Hodge dual is zero.\n\nSee also hodgedual and flipdual.\n\nExamples\n\njulia> @basis Cl(2,0,1)\n[ Info: Defined basis blades v, v1, v2, v3, v12, v13, v23, v123\n\njulia> hodgedual(v3), v3*v123 # Hodge dual is zero because v3*v3 == 0\n(0, 0)\n\njulia> poincaredual(v3)\nBasisBlade{Cl(2,0,1), 2, Int64}:\n 1 v12\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.rcontract-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.rcontract","text":"a â¨½ b\nrcontract(a, b)\n\nRight contraction of multivectors.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a â¨½ b is defined as the grade p - q part of a*b.\n\nSee also lcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.reversion-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.reversion","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector a, the reversion is reversion_sign(k)*a where the sign is given by (-1)^k(k - 1)2.\n\nSee also involution and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.scalar_prod-Tuple{Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.scalar_prod","text":"a âŠ™ b\nscalar_prod(a, b) -> Number\n\nScalar part of the multivector product a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.wedge-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.wedge","text":"a âˆ§ b\nwedge(a, b)\n\nWedge product of multivectors, a.k.a. the outer, exterior or alternating product.\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a âˆ§ b is defined as the grade p + q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.matrix_repr","page":"Reference","title":"GeometricAlgebra.matrix_repr","text":"matrix_repr(a::AbstractMultivector, k=0:dim)\n\nMatrix representation of the grade k parts of a multivector.\n\nBy default, the full 2^d  2^d linear representation is used in d dimensions. Smaller representations can be used for elements in\n\nthe even subalgebra, k=0:2:dim\nthe scalar-pseudoscalar subalgebra, k=(0, dim)\n\nby restricting k to those grades.\n\nExamples\n\njulia> @basis 2\n[ Info: Defined basis blades v, v1, v2, v12\n\njulia> matrix_repr(v + 7v12)\n4Ã—4 Matrix{Int64}:\n 1   0  0  -7\n 0   1  7   0\n 0  -7  1   0\n 7   0  0   1\n\njulia> matrix_repr(v + 7v12, (0, 2))\n2Ã—2 Matrix{Int64}:\n 1  -7\n 7   1\n\njulia> matrix_repr(v1*v2) == matrix_repr(v1)matrix_repr(v2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#Metric-Signatures","page":"Reference","title":"Metric Signatures","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"signatures.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.Cl","page":"Reference","title":"GeometricAlgebra.Cl","text":"Cl(p, q=0, r=0)\n\nMetric signature where p, q and r are the number of basis vectors of norm +1, -1 and 0, respectively.\n\nExamples\n\njulia> basis(Cl(1,3))\n4-element Vector{BasisBlade{Cl(1,3), 1, Int64}}:\n v1\n v2\n v3\n v4\n\njulia> ans .^ 2\n4-element Vector{BasisBlade{Cl(1,3), 0, Int64}}:\n  1\n -1\n -1\n -1\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.basis-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.basis","text":"basis(sig; grade=1)\n\nVector of basis blades of specified grade(s) for the geometric algebra defined by the metric signature sig. The value grade=:all is a shortcut for grade=0:dimension(sig).\n\nSee also @basis and @basisall.\n\nExamples\n\njulia> basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n v1\n v2\n v3\n\njulia> basis(\"-+++\", grade=0:2:4)\n8-element Vector{BasisBlade{âŸ¨-+++âŸ©, _A, Int64} where _A}:\n 1\n v12\n v13\n v23\n v14\n v24\n v34\n v1234\n\njulia> basis(Cl(1,3), grade=:all) |> sum\n16-component Multivector{Cl(1,3), 0:4, Vector{Int64}}:\n 1\n 1 v1 + 1 v2 + 1 v3 + 1 v4\n 1 v12 + 1 v13 + 1 v23 + 1 v14 + 1 v24 + 1 v34\n 1 v123 + 1 v124 + 1 v134 + 1 v234\n 1 v1234\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.cayleytable-Tuple","page":"Reference","title":"GeometricAlgebra.cayleytable","text":"cayleytable(sig, op=*)\ncayleytable(objs, op=*)\n\nDisplay a multivector multiplication table.\n\nThe first argument may be a metric signature or any vector of objects which can be combined with the binary operator op.\n\nThe keyword argument title sets the contents of the top-left cell.\n\nExamples\n\njulia> cayleytable(3)\n (â†“) * (â†’) â”‚    1 â”‚   v1     v2    v3 â”‚  v12    v13   v23 â”‚ v123\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n         1 â”‚    1 â”‚   v1     v2    v3 â”‚  v12    v13   v23 â”‚ v123\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n        v1 â”‚   v1 â”‚    1    v12   v13 â”‚   v2     v3  v123 â”‚  v23\n        v2 â”‚   v2 â”‚ -v12      1   v23 â”‚  -v1  -v123    v3 â”‚ -v13\n        v3 â”‚   v3 â”‚ -v13   -v23     1 â”‚ v123    -v1   -v2 â”‚  v12\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n       v12 â”‚  v12 â”‚  -v2     v1  v123 â”‚   -1   -v23   v13 â”‚  -v3\n       v13 â”‚  v13 â”‚  -v3  -v123    v1 â”‚  v23     -1  -v12 â”‚   v2\n       v23 â”‚  v23 â”‚ v123    -v3    v2 â”‚ -v13    v12    -1 â”‚  -v1\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n      v123 â”‚ v123 â”‚  v23   -v13   v12 â”‚  -v3     v2   -v1 â”‚   -1\n\njulia> cayleytable(basis((t=-1, x=1, y=1, z=1), grade=2), âˆ§)\n (â†“) âˆ§ (â†’) â”‚   tx     ty    xy    tz     xz    yz\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n        tx â”‚    0      0     0     0      0  txyz\n        ty â”‚    0      0     0     0  -txyz     0\n        xy â”‚    0      0     0  txyz      0     0\n        tz â”‚    0      0  txyz     0      0     0\n        xz â”‚    0  -txyz     0     0      0     0\n        yz â”‚ txyz      0     0     0      0     0\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentstype-Tuple{Any, Any, Any}","page":"Reference","title":"GeometricAlgebra.componentstype","text":"componentstype(sig, N, T)\n\nDefault array type used to store components of multivectors of signature sig. The resulting type should be able to store N components (in the case of a fixed-size array) of type T.\n\nThe fallback method returns Vector{T} for dimension(sig) <= 8, and SparseVector{T} otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ncomponents-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.ncomponents","text":"ncomponents(sig)\nncomponents(sig, k)\n\nDimension of (the grade-k subspace of) the geometric algebra of metric signature sig, viewed as a vector space.\n\nIf the dimension of the underlying vector space (see dimension) in n, then the algebra is 2^n-dimensional, and its grade-k subspace binomnk-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_basis_blade-Tuple{Any, Any, Any}","page":"Reference","title":"GeometricAlgebra.show_basis_blade","text":"show_basis_blade(io, sig, indices::Vector{Int})\n\nShow the basis blade with unit vectors in indices for the geometric algebra defined by sig. Methods dispatching on sig should be added to customise basis blade labels for particular algebras.\n\nExamples\n\njulia> GeometricAlgebra.show_basis_blade(stdout, (1, 1, 1), [1, 3])\nv13\n\njulia> using GeometricAlgebra: subscript\n\njulia> GeometricAlgebra.show_basis_blade(io, sig, indices) = print(io, join(\"ğ’†\".*subscript.(indices), \"âˆ§\"))\n\njulia> prod(basis(4))\nBasisBlade{âŸ¨++++âŸ©, 4, Int64} of grade 4:\n 1 ğ’†â‚âˆ§ğ’†â‚‚âˆ§ğ’†â‚ƒâˆ§ğ’†â‚„\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_signature-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.show_signature","text":"show_signature(io, sig)\n\nPretty-print the metric signature sig.\n\nThis is used to display the metric signature type parameter in AbstractMultivector subtypes to reduce visual noise. Methods may optionally be added for user-defined metric signatures, in a similar fashion to Base.show.\n\nExamples\n\njulia> sig = (+1,-1,-1,-1)\n(1, -1, -1, -1)\n\njulia> GeometricAlgebra.show_signature(stdout, sig)\nâŸ¨+---âŸ©\n\njulia> BasisBlade{sig}\nBasisBlade{âŸ¨+---âŸ©} (pretty-printed BasisBlade{(1, -1, -1, -1)})\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.@basis-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.@basis","text":"@basis sig\n\nPopulate namespace with basis blades of every grade in the geometric algebra with metric signature sig.\n\nwarning: Warning\nThis defines 2^n variables for an n dimensional signature.\n\nSee also @basisall.\n\nExamples\n\njulia> @basis 3\n[ Info: Defined basis blades v, v1, v2, v3, v12, v13, v23, v123\n\njulia> 1v2 + 3v12\n8-component Multivector{3, 0:3, Vector{Int64}}:\n 1 v2\n 3 v12\n\n\n\n\n\n","category":"macro"},{"location":"reference/#GeometricAlgebra.@basisall-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.@basisall","text":"@basisall sig\n\nSimilarly to @basis, populate namespace with basis blades, but include all permutations of each blade (e.g., v21 as well as v12).\n\nwarning: Warning\nThis defines more than 2^n variables for an n dimensional signature!\n\nExamples\n\njulia> @basisall (+1,-1)\n[ Info: Defined basis blades v, v1, v2, v12, v21\n\njulia> v12 == -v21\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Internals","page":"Reference","title":"Internals","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"bits.jl\", \"grades.jl\", \"show.jl\", \"generated.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.BitPermutations","page":"Reference","title":"GeometricAlgebra.BitPermutations","text":"BitPermutations{T}(n)\n\nInfinite iterator returning all unsigned integers of type T, in ascending order, for which Base.count_ones is n.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.bits_of_grade-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.bits_of_grade","text":"bits_of_grade(k[, dim])\n\nGenerate basis blade bits of grade k in ascending order. Yields all basis blades in the dimension dim, if given, otherwise iterates indefinitely.\n\nExamples\n\njulia> GeometricAlgebra.bits_of_grade(2, 4) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.bits_to_indices-Tuple{Unsigned}","page":"Reference","title":"GeometricAlgebra.bits_to_indices","text":"bits_to_indices(bits)\n\nReturn the positions of the ones in the unsigned integer bits.\n\nUsed to convert between representations of a unit blade. Inverse of indices_to_bits.\n\nExamples\n\njulia> GeometricAlgebra.bits_to_indices(0b1001101)\n4-element Vector{Int64}:\n 1\n 3\n 4\n 7\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentbits-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.componentbits","text":"componentbits(n, k)\ncomponentbits(::Val{N}, ::Val{K})\n\nVector of bits corresponding to components of an n-dimensional Multivector of grade(s) k.\n\nBits are ordered first by grade (count_ones), then lexicographically (in ascending numerical order).\n\nPassing Val arguments calls a faster, memoized method.\n\nExamples\n\njulia> componentbits(4, 2) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\njulia> componentbits(3, 0:3) .|> UInt8 .|> bitstring\n8-element Vector{String}:\n \"00000000\"\n \"00000001\"\n \"00000010\"\n \"00000100\"\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00000111\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.factor_from_squares-Tuple{Any, Unsigned}","page":"Reference","title":"GeometricAlgebra.factor_from_squares","text":"factor_from_squares(sig, bits::Unsigned)\n\nCompute the overall factor arising from the geometric product between repeated basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.geometric_prod_bits-Tuple{Any, Unsigned, Unsigned}","page":"Reference","title":"GeometricAlgebra.geometric_prod_bits","text":"geometric_prod_bits(sig, a::Unsigned, b::Unsigned)\n\nCompute the geometric product between unit blades. Returns a tuple of the overall scalar factor and the resulting unit blade.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.indices_to_bits","page":"Reference","title":"GeometricAlgebra.indices_to_bits","text":"indices_to_bits(indices, T=UInt)\n\nCreate unsigned integer with bits at the positions given in the vector indices.\n\nUsed to convert between representations of a unit blade. Inverse of bits_to_indices.\n\nwarning: Warning\nOnly correct if maximum(indices) does not exceed number of bits in T.\n\nExamples\n\njulia> GeometricAlgebra.indices_to_bits([1, 2, 5], UInt8) |> bitstring\n\"00010011\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.next_bit_permutation-Tuple{Unsigned}","page":"Reference","title":"GeometricAlgebra.next_bit_permutation","text":"Return the smallest uint larger than the one given which has the same number of binary ones. Algorithm is Gosperâ€™s hack.\n\nExamples\n\njulia> GeometricAlgebra.next_bit_permutation(0b1011) |> bitstring\n\"00001101\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.reversion_sign-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.reversion_sign","text":"reversion_sign(k) = mod(k, 4) <= 1 ? +1 : -1\n\nSign from reversing a k-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.sign_from_swaps-Tuple{Unsigned, Unsigned}","page":"Reference","title":"GeometricAlgebra.sign_from_swaps","text":"sign_from_swaps(a::Unsigned, b::Unsigned)\n\nCompute sign flips of blade product due to transposing basis vectors into sorted order. (The full sign of the product will also depend on the basis norms.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{Multivector, Any}","page":"Reference","title":"Base.getindex","text":"a[k]\ngetindex(a::Multivector, k)\n\nGet the grade(s) k part of a multivector a if k âŠ† grade(a). The components of the resulting Multivector are a view into the components of a, so a may be modified like a[k].comps[i] = ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentslice-Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:Multivector, Integer}","page":"Reference","title":"GeometricAlgebra.componentslice","text":"componentslice(a, k)\n\nIndices of components of grade(s) k in multivector a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.grade-Tuple{BasisBlade, Any}","page":"Reference","title":"GeometricAlgebra.grade","text":"grade(a::Multivector{Sig}, k) -> Multivector{Sig,k}\n\nGrade k part of a multivector a. Returns a zero k-vector if k âˆ‰ grade(a).\n\nMultiple grades may be given as a range or tuple. The operators + and - may be used as shortcuts for the even and odd parts, respectively.\n\nExamples\n\njulia> mv = Multivector{Cl(2,1), 0:4}(1:8)\n8-component Multivector{Cl(2,1), 0:4, UnitRange{Int64}}:\n 1\n 2 v1 + 3 v2 + 4 v3\n 5 v12 + 6 v13 + 7 v23\n 8 v123\n\njulia> grade(mv, 2)\n3-component Multivector{Cl(2,1), 2, UnitRange{Int64}}:\n 5 v12\n 6 v13\n 7 v23\n\njulia> grade(mv, (0, 3))\n2-component Multivector{Cl(2,1), (0, 3), SubArray{Int64, 1, UnitRange{Int64}, Tuple{Vector{Int64}}, false}}:\n 1\n 8 v123\n\njulia> grade(mv, +) # only even grades\n4-component Multivector{Cl(2,1), 0:2:2, SubArray{Int64, 1, UnitRange{Int64}, Tuple{Vector{Int64}}, false}}:\n 1\n 5 v12 + 6 v13 + 7 v23\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.promote_grades-Tuple{Integer, Any, Any}","page":"Reference","title":"GeometricAlgebra.promote_grades","text":"promote_grades(dim, p, q, ...)\n\nReturn a suitable grade type parameter which contains the grades p âˆª q âˆª ....\n\nIn order to reduce the number of possible type parameters, the result may be larger than the exact union. Specifically, when combining different grades, promote_grades will try to return the narrowest grade(s) out of:\n\nan integer k âˆˆ 0:dim for homogeneous elements (fewest components)\n(0, dim), for elements in the scalar-pseudoscalar subalgebra\n0:2:dim, for elements in the even subalgebra\n0:dim, for general inhomogeneous elements (most components)\n\nExamples\n\njulia> promote_grades(4, 0:4, 2, 7)\n0:4\n\njulia> promote_grades(4, 0, 2) # even multivectors are worth representing specifically\n0:2:4\n\njulia> promote_grades(4, 0, 3) # not worth having a specific type for grades (0, 3) in 4 dims\n0:4\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.promote_grades-Tuple{Integer, Integer}","page":"Reference","title":"GeometricAlgebra.promote_grades","text":"promote_grades(dim, k)\n\nCanonicalize the grade type parameter k.\n\nReturns a subset of 0:dim, while attempting to normalize equivalent representations, such as 0:1:3 => 0:3 or (3, 0) => (0, 3).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.resulting_grades-NTuple{4, Any}","page":"Reference","title":"GeometricAlgebra.resulting_grades","text":"resulting_grades(combine, dim, p, q)\n\nNon-zero grade(s) resulting from the application of combine on dim-dimensional multivectors of grade(s) p and q.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_blade-Tuple{IO, BasisBlade}","page":"Reference","title":"GeometricAlgebra.show_blade","text":"Display blade with parentheses surrounding coefficient if necessary.\n\nExample\n\njulia> GeometricAlgebra.show_blade(stdout, BasisBlade{(x=1,)}(0b1 => 1 + im))\n(1+1im) x\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_multivector-Tuple{IO, Any}","page":"Reference","title":"GeometricAlgebra.show_multivector","text":"Display multivector components in a column or inline, optionally grouping by grade.\n\nParameters:\n\ninline::Bool: print on one line (default true)\ngroupgrades::Bool: visually group components by grade (default true).  If inline, draws parentheses around parts of each grade; if multiline, draw  each grade on its own line\nshowzeros::Bool: whether to omit zero components from display\nindent::Integer: indent amount\n\nExamples\n\njulia> a = Multivector{2,0:2}((1:4) .^ 2);\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=false)\n 1 v\n 4 v1\n 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=true)\n1\n4 v1 + 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=true)\n(1) + (4 v1 + 9 v2) + (16 v12)\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=false)\n1 + 4 v1 + 9 v2 + 16 v12\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.symbolic_multivector_eval-Tuple{Function, Vararg{Any}}","page":"Reference","title":"GeometricAlgebra.symbolic_multivector_eval","text":"symbolic_multivector_eval(f, x::AbstractMultivector...)\n\nEvaluate f(x...) using symbolically generated code.\n\nThis is a generated function which first evaluates f on symbolic versions of the multivector arguments x and then converts the symbolic result into unrolled code.\n\nCalling symbolic_multivector_eval(Expr, f, x...) with Expr as the first argument returns the unevaluated code as an expression (for introspection).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.use_symbolic_optim-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.use_symbolic_optim","text":"use_symbolic_optim(sig) -> Bool\n\nWhether to use symbolic code generation to optimize operations in algebras of metric signature sig.\n\nBy default, this is enabled if dimension(sig) â‰¤ 8 as a heuristic (in many dimensions, algebraic expressions may become too unwieldy).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.@symbolic_optim-Tuple{Expr}","page":"Reference","title":"GeometricAlgebra.@symbolic_optim","text":"GeometricAlgebra.@symbolic_optim\n\nConvert a single method definition f(x...) into two methods:\n\nthe original method f(Val(:nosym), x...), called with Val(:nosym) as the first argument as a way to opt-out of the symbolic optimization.\nan optimized method f(x...) which uses symbolic_multivector_eval to generate code by calling f(Val(:nosym), x...) on symbolic versions of the Multivector arguments x.\n\nThis is to reduce boilerplate when writing functions with Multivectors that would benefit from using this optimization by default.\n\nExample\n\n@symbolic_optim foo(a, b) = (a + b)^2\n# ...is equivalent to defining the two methods below:\n\nfoo(::Val{:nosym}, a, b) = (a + b) ^ 2\n\nfunction foo(a, b)\n    if use_symbolic_optim(foo, a, b)\n        symbolic_multivector_eval(foo, Val(:nosym), a, b)\n    else\n        foo(Val(:nosym), a, b)\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"#GeometricAlgebra","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"","category":"section"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"GeometricAlgebra.jl implements flexible types for working with geometric (or Clifford) algebras.","category":"page"},{"location":"#Quick-Start","page":"GeometricAlgebra","title":"Quick Start","text":"","category":"section"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Construct multivectors by providing a metric signature and grade as type parameters:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> using GeometricAlgebra\n\njulia> u = Multivector{3,1}([1, -1, 0]) # 3D Euclidean vector\n3-component Multivector{3, 1, Vector{Int64}}:\n  1 v1\n -1 v2\n  0 v3","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Non-euclidean metric signatures may be specified:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> v = Multivector{(-1,1,1,1),2}(1:6) # Lorentzian bivector\n6-component Multivector{âŸ¨-+++âŸ©, 2, UnitRange{Int64}}:\n 1 v12\n 2 v13\n 3 v23\n 4 v14\n 5 v24\n 6 v34\n\njulia> exp(v)\n8-component Multivector{âŸ¨-+++âŸ©, 0:2:4, Vector{Float64}}:\n 1.18046\n 0.818185 v12 + -0.141944 v13 + 0.153208 v23 + 1.076 v14 + 1.16194 v24 + 1.03866 v34\n 0.999268 v1234","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Notice that this bivector exponential has grades 0:2:4. The grade parameter K of a Multivector{Sig,K} can be a single integer (for homogeneous multivectors) or a collection of grades. Storing the even part of exp(v) (8 components) is more efficient than the full 4D multivector (16 components).","category":"page"},{"location":"#Working-with-an-orthonormal-basis","page":"GeometricAlgebra","title":"Working with an orthonormal basis","text":"","category":"section"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"You may also obtain an orthonormal basis for a metric signature:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> v = basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n v1\n v2\n v3","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Macros are provided for interactive use:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> @basis \"+---\"\n[ Info: Defined basis blades v, v1, v2, v3, v4, v12, v13, v14, v23, v24, v34, v123, v124, v134, v234, v1234\n\njulia> @basisall (t = +1, x = -1)\n[ Info: Defined basis blades t, x, tx, xt","category":"page"}]
}
