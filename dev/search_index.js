var documenterSearchIndex = {"docs":
[{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/dualities/#Dualities","page":"Dualities","title":"Dualities","text":"","category":"section"},{"location":"theory/dualities/#Pseudoscalar-duality","page":"Dualities","title":"Pseudoscalar duality","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The highest-grade elements of geometric algebras are called pseudoscalars. The unit pseudoscalar","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"I  ğ¯_1ğ¯_2ğ¯_n","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"plays an important role, and may be interpreted as an oriented unit volume.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"warning: Warning\nThe unit pseudoscalar I is not to be confused with the identity matrix or unit imaginary i. Indeed, I does not always commute, and I^2 = 1 depending on the algebra.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"Multiplying by I sends k-vectors to (n - k)-vectors. In odd dimensions, left- and right-multiplication by the unit pseudoscalar is identical:","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"AI = IA\nquadtext(in odd dimensions)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"for any multivector A. However, in even dimensions, odd-grade elements anticommute with I.","category":"page"},{"location":"theory/dualities/#Hodge-duality","page":"Dualities","title":"Hodge duality","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"hodgedual(A)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The Hodge dual is a combination of reversion and multiplication by I:","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"mathsfhodgedual(A) = tildeAI","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"This comes from the Hodge star operator from exterior algebra, which is a metrical duality operation implicitly defined on two k-vectors A and B by","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"A  mathsfhodgedual(B) = A B I","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"where A B is the induced inner product on k-vectors. In the language of geometric algebra, this is","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"A B = A odot tildeB = A lcontr tildeB","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"and by using the identity (A lcontr tildeB)I = A  (tildeBI) we have A  mathsfhodgedual(B) = A  (tildeBI) which shows the equivalence with the explicit definition above.","category":"page"},{"location":"theory/dualities/#Comparison-with-pseudoscalar-duality","page":"Dualities","title":"Comparison with pseudoscalar-duality","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"For homogeneous multivectors, Hodge duality and pseudoscalar-duality differ only in overall sign.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The square of the Hodge dual is mathsfhodgedual^2(A) = (-1)^s(-1)^k(n - k) A and hence the inverse is","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"mathsfhodgedual^-1(A) = (-1)^s(-1)^k(n - k) mathsfhodgedual(A) ","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"where s is the trace of the metric.[1] Note that this depends on the grade k of A.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"[1]: Lemma 6, [2]","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"By contrast, I^2 = 1 and hence I^-1 = I does not depend on the multivector it acts on. (This generally makes pseudoscalar-duality easier to work with algebraically!)","category":"page"},{"location":"theory/dualities/#Left-and-right-complements","page":"Dualities","title":"Left and right complements","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"ldual, rdual","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The left and right complements are dual operations which do not involve multiplication by the pseudoscalar I, and so are metric independent. Some authors denote the left and right complements by underlineA and overlineA, respectively.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"For a unit basis blade a, the complements are uniquely defined by","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"textsfldual(a)a = I = atextsfrdual(a)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"and are extended linearly to act on general multivectors. They are inverses of each other,","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"textsfldual(textsfrdual(a)) = a = textsfrdual(textsfldual(a))","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"and in odd-dimensional algebras, are identical.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The metric-independence of the left and right duals mean they are useful even in degenerate algebras, since a non-zero multivector always has a non-zero dual even when its Hodge dual is zero.","category":"page"},{"location":"theory/dualities/#Dualized-products","page":"Dualities","title":"Dualized products","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"It is common to work both with multivectors and their duals in the same context, and hence convenient to define â€œdualizedâ€ versions of certain products. For example, the regressive product  is the dualized wedge product , defined by","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"D(a  b) = D(a)  D(b)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"where D is a dual operation such as textsfldual or textsfrdual (each results in an equivalent definition).","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"In the context of point-based projective geometric algebra, the -product of two objects forms the join (e.g., the line joining two points) while the -product of two objects forms the meet (e.g., the point where two lines meet) and vice versa in plane-based PGA.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"Similar products may be defined by dualizing the inner product and contractions[2] but these are less common.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"[2]: See the â€œanti-productsâ€ defined in Lengyelâ€™s wiki.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/products/#Wedge,-Inner-and-Other-Products","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The geometric product is the fundamental operation in geometric algebra. Together with grade projection phantomA_k, various other â€œgraded productsâ€ may be defined by taking different projections of the geometric product.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"To motivate this, consider a p-vector A and q-vector B. The geometric product contains parts of every grade between the difference p - q and sum p + q in steps of two:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"AB = AB_p - q + AB_p - q + 2 +  + AB_p + q - 2 + AB_p + q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Some of these parts are often useful on their own, and so warrant their own name.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"These are summarised below, where the grade of the result is shown for each product between a p-vector and q-vector.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Name Function Symbol REPL shortcut Resulting grade\nscalar product scalar_prod odot \\odot<tab> 0\nwedge/outer product wedge  \\wedge<tab> p + q\ninner product inner  \\cdot<tab> p - q\nleft contraction lcontract lcontr \\intprod<tab> q - p\nright contraction rcontract rcontr \\intprodr<tab> p - q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"To glance at a multiplication table for a product, you can use cayleytable. For example, left contraction in Cl(11) looks like:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"using GeometricAlgebra # hide\ncayleytable(Cl(1,1), â¨¼)","category":"page"},{"location":"theory/products/#Scalar-product","page":"Wedge, Inner and Other Products","title":"Scalar product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A âŠ™ B or scalar_prod(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The scalar product is simply the scalar part of the geometric product:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  AB_0","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"It is also commonly denoted A  B or AB.","category":"page"},{"location":"theory/products/#wedge","page":"Wedge, Inner and Other Products","title":"Wedge product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A âˆ§ B or wedge(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The wedge product may be thought of as the highest-grade part of the geometric product. For example, if A and B are multivectors of grade p and q, respectively, then A  B = AB_p + q. This definition can be extended linearly to general multivectors as","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  sum_pq bigA_p B_qbig_p + q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Between a vector ğ’– and a multivector A, the wedge product may be written as","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"ğ’–  A = frac12(ğ’–A + A^star ğ’–)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"where A^star denotes involution. Between two vectors, the wedge product is the antisymmetric part of the product:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"ğ’–  ğ’— = frac12(ğ’–ğ’— - ğ’—ğ’–)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"More generally, the wedge product of many vectors may be written as an antisymmetrised geometric product","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"ğ’–_1    ğ’–_k = frac1ksum_Ïƒ  S_k operatornamesign(Ïƒ) ğ’–_Ïƒ(1)  ğ’–_Ïƒ(k)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"where the sum is over all permutations Ïƒ of the indices 1  k. This shows the connection to antisymmetric tensors.","category":"page"},{"location":"theory/products/#Generalised-inner-product","page":"Wedge, Inner and Other Products","title":"Generalised inner product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A â‹… B or inner(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"To complement the wedge product, the generalised inner product is the lowest-grade part of the geometric product. For general multivectors, define","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  sum_pq bigA_p B_qbig_p - q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Strictly speaking, this should not be confused with the vector inner product, although they are equivalent on vectors.","category":"page"},{"location":"theory/products/#Left-and-right-contractions","page":"Wedge, Inner and Other Products","title":"Left and right contractions","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A â¨¼ B, A â¨½ B or lcontract(A, B), rcontract(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The left and right contractions are similar to the generalised inner product, except that they do not involve an absolute value (which arguably makes them more â€˜uniformâ€™).","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"beginalign*\nA lcontr B  sum_pq bigA_p B_qbig_q - p\ntext(left contraction)\n\nA rcontr B  sum_pq bigA_p B_qbig_p - q\ntext(right contraction)\nendalign*","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"With a vector ğ’–, we have the general formulae","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"beginalign*\nğ’– lcontr A = frac12(ğ’–A - A^starğ’–)\n\nA rcontr ğ’– = frac12(Ağ’– - ğ’–A^star)\nendalign*","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The link with the inner product can be seen if A_p is a p-vector and B_q a q-vector, so that","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A_p  B_q = begincases A_p lcontr B_q  p  q  A_p rcontr B_q  p  q endcases","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"and indeed A  B = A lcontr B = A rcontr B = A  B if p = q.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Despite their similarities, the contractions are arguably better behaved than the inner product, since identities with the inner product tend to involve grade-based exceptions while identities with contractions tend to hold in full generally. (See [1] for discussion).","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"For instance, the contractions obey an associativity relation","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"(A lcontr B) rcontr C = A lcontr (B rcontr C)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"for all multivectors A B and C, and interact nicely with the wedge product with the identities","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"beginalign*\n\t(A lcontr B)I = A  (BI)\n\tI(A rcontr B) = (IA)  B\n\tA lcontr (B lcontr C) = (A  B) lcontr C\n\t(A rcontr B) rcontr C = A rcontr (B  C)\n\tA odot (B lcontr C) = (A  B) odot C\n\t(A rcontr B) odot C = A odot (B  C)\nendalign*","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"where I is the unit pseudoscalar.[1]","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"[1]: Section 3.3, [2]","category":"page"},{"location":"theory/products/#Other-Products","page":"Wedge, Inner and Other Products","title":"Other Products","text":"","category":"section"},{"location":"theory/products/#Commutator-product","page":"Wedge, Inner and Other Products","title":"Commutator product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The commutator product is defined as","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  frac12(AB - BA)","category":"page"},{"location":"theory/references/","page":"References","title":"References","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"theory/references/","page":"References","title":"References","text":"L.Â Dorst. The Inner Products of Geometric Algebra. In: Applications of Geometric Algebra in Computer Science and Engineering, edited by L.Â Dorst, C.Â Doran and J.Â Lasenby (BirkhÃ¤user, Boston, MA, 2002); pp.Â 35â€“46.\n\n\n\nJ.Â Wilson. Geometric Algebra for Special Relativity and Manifold Geometry. Master's thesis, Victoria University of Wellington (Sep 2022).\n\n\n\nE.Â Hitzer and S.Â Sangwine. Multivector and multivector matrix inverses in real Clifford algebras. AppliedÂ MathematicsÂ andÂ Computation 311, 375â€“389 (2017).\n\n\n\nD.Â Prodanov. Algorithmic Computation of Multivector Inverses and Characteristic Polynomials in Non-degenerate Clifford Algebras. In: Advances in Computer Graphics, edited by B.Â Sheng, L.Â Bi, J.Â Kim, N.Â Magnenat-Thalmann and D.Â Thalmann (Springer Nature Switzerland, Cham, 2024); pp.Â 379â€“390.\n\n\n\n","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/special/#Inverses,-Roots-and-Logarithms","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"","category":"section"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"In general, finding the inverse A^-1, square root sqrtA or logarithm log A of a general multivector A is difficult. However, for certain cases, explicit formulae exist.","category":"page"},{"location":"theory/special/#Multivector-inverses","page":"Inverses, Roots and Logarithms","title":"Multivector inverses","text":"","category":"section"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"Any multivector A has either no inverse or exactly one inverse A^-1 such that AA^-1 = A^-1A = 1.","category":"page"},{"location":"theory/special/#Explicit-formulae-for-multivector-inverses","page":"Inverses, Roots and Logarithms","title":"Explicit formulae for multivector inverses","text":"","category":"section"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"For any metric in up to five dimensions, explicit formulae exist for the inverse of a multivector A. The implementation used in GeometricAlgebra.jl is mainly based on [3] and is described here.","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"For a multivector A  Cl(â„^d ) with metric  in d dimensions, let:","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"A be the Clifford conjugate\nA be the involute\nA be the reverse\nA_K denote the negation of grades k  K, i.e.,","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"A_K = sum_k=0^d A_k  begincases\n\t-1  textif  k  K \n\t+1  textotherwise\nendcases","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"Special case Formula\nA^2  â„ A^-1 = fracAA^2\nd = 3 A^-1 = fracAAAAAAA\nd = 4 A^-1 = fracBAB B = AAA_34\nd = 5 A^-1 = fracBAB B = AAAAAAA_14","category":"page"},{"location":"theory/special/#Faddeevâ€“LeVerrier-inverse-algorithm","page":"Inverses, Roots and Logarithms","title":"Faddeevâ€“LeVerrier inverse algorithm","text":"","category":"section"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"The Faddeevâ€“LeVerrier inverse algorithm may be used to find the inverse of an n times n matrix A in exactly n steps (with one matrix multiplication per step). This algorithm can also be used to invert elements in a geometric algebra by considering a linear representation of multivectors as n times n matrices. [4] This method is implemented in inv_flv_method.","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"Crucially, we do not actually need to find a linear representation to use this method: we only need to know that one exists for a given dimension n. Assume the dimension of the smallest representation is textrepsize(A).","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"Algorithm pseudocode","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"given a multivector A\nn = textrepsize(A)\nc_n = 1\nN leftarrow 1\nfor k in (n - 1 n - 2  1 0)\nâ€ƒ N leftarrow N + c_k + 1 I\nâ€ƒ c_k = fracnk - n A odot N\nreturn A^-1 = -Nc_0","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"The inverse exists if and only if c_0 ne 0.","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"If A is a d-dimensional multivector, then:","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"textrepsize(A) = begincases\n\t1  A = A_0 \n\t2  textA is a pseudoscalar or (pseudo)vector \n\t2^lfloor d2 rfloor  textA is even \n\t2^lceil d2 rceil  textin general \nendcases","category":"page"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"In some cases, the algorithm works in fewer steps than given above, particularly for multivectors of particular grades. However, I have not figured out how to determine the true minimum number of steps. (For example, by inspection, inverting a 5-dimensional 3-vector requires only n = 4 steps, not 8 as suggested by this prescription.) It's an interesting problem!","category":"page"},{"location":"theory/special/#Formulae-for-multivector-square-roots","page":"Inverses, Roots and Logarithms","title":"Formulae for multivector square roots","text":"","category":"section"},{"location":"theory/special/","page":"Inverses, Roots and Logarithms","title":"Inverses, Roots and Logarithms","text":"Special case Formula\nA^2  â„ A^2  0 sqrtA = fracA + Î»sqrt2Î» Î» = sqrt-A^2\nA^2  â„ A^2  0 I^2 = -1 AI = IA sqrtA = fracA + IÎ»(1 + I)sqrtÎ» Î» = sqrtA^2","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"using GeometricAlgebra","category":"page"},{"location":"design/#Design-and-Internals","page":"Design and Internals","title":"Design and Internals","text":"","category":"section"},{"location":"design/#Multivector-Types","page":"Design and Internals","title":"Multivector Types","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"There are two concrete types for representing elements in a geometric algebra:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}    Multivector{Sig,K,S}","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"BasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Type parameters:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Sig: The metric signature which defines the geometric algebra. This can be any  all-bits value which satisfies the metric signature interface.\nK: The grade(s) of a multivector. For BasisBlades, this is an integer, but for Multivectors, it may be a collection (e.g., 0:3 for a general 3D multivector).\nT: The numerical type of the coefficient of a BasisBlade.\nS: The storage type of the components of a Multivector, usually an AbstractVector subtype.","category":"page"},{"location":"design/#sig","page":"Design and Internals","title":"Metric Signatures","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter Sig defines the dimension of the geometric algebra and the norms of its standard orthonormal basis vectors. Additionally, it allows various default behaviours to be customised through method definitions which dispatch on Sig, as detailed in the metric signature interface.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, the following metric signature types are implemented:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Int, defining a Euclidean metric of that dimension,\nTuple, defining the norms of each basis vector,\nNamedTuple, defining basis vector labels as well as norms,\nCl, a type resembling the notation Cl(p q r) common in literature.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> @basis 2\n[ Info: Defined basis blades v1, v2, v12, I in Main\n\njulia> basis((t=-1, x=1, y=1, z=1)) |> prod\nBasisBlade{(t = -1, x = 1, y = 1, z = 1), 4, Int64}:\n 1 txyz\n\njulia> sum(basis(Cl(\"++\"))) # shorthand for metric signature (1, 1)\n2-component Multivector{Cl(\"++\"), 1, SVector{2, Int64}}:\n 1 v1\n 1 v2","category":"page"},{"location":"design/#sig-interface","page":"Design and Internals","title":"The metric signature interface","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter may be any isbits value satisying the following interface. As well as defining the geometric algebra, the signature is used to specify basis blade labels, the default array type for multivector components, and other metadata.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Required methods Description\ndimension(sig) The dimension of the underlying vector space, or number of basis vectors.\nbasis_vector_square(sig, i) The scalar square of the ith basis vector.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Optional methods Description\nshow_signature(io, sig) Show the metric signature in a compact human-readable form.\nshow_basis_blade(io, sig, indices) Print a basis blade with the given indices (e.g., v12 or ğ’†â‚âˆ§ğ’†â‚‚).\nbits_to_indices(sig, bits) Define display order of indices for a basis blade (must also implement basis_blade_parity(sig, bits) consistently).\ncomponentstype(sig, N) Preferred array type for Multivector{sig} components. (E.g., Vector, MVector, SparseVector, etc.)\nuse_symbolic_optim(sig) Whether to use symbolic code generation to optimise multivector products. (Default is true for low dimensions.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Below is an example of how one might define a â€œprojectivisedâ€ signature which adds a projective dimension ğ¯_0 squaring to -1 to any signature:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"import GeometricAlgebra: dimension, basis_vector_square, show_signature, show_basis_blade\n\nstruct â„™{Sig} end\nâ„™(sig) = â„™{sig}()\n\ndimension(::â„™{Sig}) where Sig = dimension(Sig) + 1\nbasis_vector_square(::â„™{Sig}, i) where Sig = i == 1 ? -1 : basis_vector_square(Sig, i - 1)\nshow_signature(io::IO, ::â„™{Sig}) where Sig = print(io, \"â„™($Sig)\")\n\nshow_basis_blade(io::IO, ::â„™, indices::Vector) = print(io, \"v\", join(indices .- 1))\n\nbasis(â„™(3)) |> sum","category":"page"},{"location":"design/#Symbolic-Algebra-and-Code-Generation","page":"Design and Internals","title":"Symbolic Algebra and Code Generation","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Thanks to the wonderful SymbolicUtils package, the same code originally written for numerical multivectors readily works with symbolic components. For example, we can compute the product of two vectors symbolically as follows:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> GeometricAlgebra.make_symbolic.(Multivector{2,1}, [:A, :B])\n2-element Vector{Multivector{2, 1, Vector{GeometricAlgebra.MiniCAS.ProductNode{GeometricAlgebra.MiniCAS.IndexNode{1}}}}}:\n A[1]v1 + A[2]v2\n B[1]v1 + B[2]v2\n\njulia> prod(ans)\n2-component Multivector{2, 0:2:2, SVector{2, GeometricAlgebra.MiniCAS.SumNode{GeometricAlgebra.MiniCAS.IndexNode{1}, Int64}}}:\n A[1] * B[1] + A[2] * B[2]\n -(A[2] * B[1]) + A[1] * B[2] v12","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"This makes it easy to optimize multivector operations: first perform the calculation symbolically and then compile the resulting analytic expression. By default, this optimization is enabled for most products (including the geometric, wedge and inner products in up to eight dimensions[1]). This is done by prefixing method definitions with the internal @symbolic_optim macro.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"[1]: This can be changed on a per-algebra basis by defining methods for use_symbolic_optim().","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Symbolic optimisation is also exposed through a user-facing macro @symbolicga, inspired by the @ga macro in serenity4/SymbolicGA.jl. This is especially useful when you want use geometric algebra without manipulating Multivector types.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"For example, using Cl(â„Â³) to represent homogeneous coordinates on the plane:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> joinpoints(p, q) = @symbolicga 3 (p=1, q=1) p âˆ§ q Tuple\njoinpoints (generic function with 1 method)\n\njulia> intersectlines(p, q) = @symbolicga 3 (p=2, q=2) rdual(ldual(p) âˆ§ ldual(q)) Tuple\nintersectlines (generic function with 1 method)\n\njulia> L1 = joinpoints((1, 0, 1), (0, 1, 1)) # line y = 1 - x\n(1, 1, -1)\n\njulia> L2 = joinpoints((0, 0, 1), (1, 1, 1)) # line y = x\n(0, -1, -1)\n\njulia> intersectlines(L1, L2) # point (0.5, 0.5)\n(-1, -1, -2)\n","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The resulting methods are loop-free and allocation-free.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"using GeometricAlgebra","category":"page"},{"location":"theory/basics/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"This is a brief overview of the mathematics of geometric algebra, using GeometricAlgebra.jl to explain features along the way.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"To follow along, install GeometricAlgebra.jl and load it with","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"julia> using GeometricAlgebra","category":"page"},{"location":"theory/basics/#Definition","page":"Introduction","title":"Definition","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Briefly, geometric algebra is what you get when vectors in a space are allowed to be multiplied freely,[1] with the rule that a vector ğ’– multiplied by itself gives its scalar dot product, ğ’–^2 = ğ’–ğ’–.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"What do you get when you multiply two different vectors? We can simplify expressions using the relation ğ’–^2 = ğ’–ğ’–, along with the usual associativity ğ’–(ğ’—ğ’˜) = (ğ’–ğ’—)ğ’˜ and distributivity (ğ’– + ğ’—)ğ’˜ = ğ’–ğ’˜ + ğ’—ğ’˜, but we may still be left with irreducible products, ğ’–ğ’—. These are a new kind of object, distinct from scalars or vectors. These objects are called multivectors.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"[1]: More formally, Cl(V ) is the freest unital associative algebra generated by V satisfying ğ’–^2 = ğ’–ğ’– for all ğ’–  V.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"What this means becomes clearer after choosing a basis. In geometric algebras, orthonormal vectors ğ¯_1  ğ¯_n  V multiply according to the rules[2]","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"ğ¯_i^2 = ğ¯_iğ¯_i,\nğ¯_iğ¯_j = -ğ¯_jğ¯_i where i  j.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"The basis vector norms ğ¯_iğ¯_i may be +1, -1 or 0 depending on the inner product  on V. The elements ğ¯_iğ¯_j are bivectors (a kind of oriented plane-element), and higher grade terms ğ¯_iğ¯_jğ¯_k are trivectors, etc.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"[2]: The second rule is implied by the first, which is the defining relation ğ’–^2 = ğ’–ğ’–.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"In code, we may obtain an orthonormal basis with basis(sig), where sig is the metric signature parameter. We may also introduce basis variables into the global namespace with the macro @basis.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 3\nv1^2 # vector square gives its norm, a scalar (or grade 0 blade)\nv2*v1 # orthogonal vectors anticommute","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"note: Terminology\nGeometric algebras are also called (real) Clifford algebras and are denoted Cl(V ) or Cl(V Q), where  has the associated quadratic form Q.Denote by Cl(n) the algebra over â„^n where  is the standard Euclidean dot product. Write Cl(pq) for V = â„^p + q where the inner product has p orthonormal basis vectors with norm +1 and q with norm -1, and Cl(pqr) if there are an additional r basis vectors which square to zero.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"note: Formal definition\nA formal construction of the geometric algebra Cl(V ) over a vector space V with inner product  is as the quotient algebra Cl(V )  V^ big I. Here, the tensor algebra V^ = â„  V  (V  V)   is reduced by the ideal I which identifies all elements of the form ğ’–  ğ’– - ğ’–ğ’– where ğ’–  V with zero. The result is a vector space isomorphic to the exterior algebra V but with an algebraic product which mixes degrees.","category":"page"},{"location":"theory/basics/#Graded-structure","page":"Introduction","title":"Graded structure","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Geometric algebras have a graded structure: every element has a grade k  0 1 2 n or is a sum of elements of differing grades. As a vector space, Cl(V ) is the direct sum of fixed-grade subspaces","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Cl(V ) = _k=0^n ^n V = â„  V  ^2 V    ^n V","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"where ^k V is the kth exterior power of the n-dimensional base space V.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Grade zero elements (^0V = â„) are scalars; grade one elements (^1V = V) are vectors; and grade-k elements (^k V) are called k-vectors or homogeneous multivectors. There are no non-zero k-vectors outside the range 0  k  n, so the subspace of ^nV contains the highest-grade objects, called pseudoscalars.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Grade Dimension of subspace Name\n0 1 scalars\n1 n vectors\n2 binomn2 bivectors\n3 binomn3 trivectors\n  \nk binomnk k-vectors\n  \nn - 1 n pseudovectors\nn 1 pseudoscalars\nall 2^n multivectors","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"info: Duality\nNotice that subspaces of grade k and n - k have the same dimension. Subspaces ^kV and their â€œpseudoâ€-prefixed counterparts ^n - kV are associated through duality.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A k-vector in n-dimensional Euclidean space is represented as a component vector wrapped in the Multivector{n,k} type.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Multivector{3,2}(rand(3))","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Elements of Cl(V ) may consist of parts of differing grade, and when they do they are called (inhomogeneous) multivectors.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"These are represented as a single contiguous component vector wrapped in a Multivector type where the grade parameter k is a range of grades. For example, a general 4D multivector is expressible as Multivector{4,0:4}.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"If the inner product  is non-Euclidean, the first type parameter n is replaced with a metric signature.","category":"page"},{"location":"theory/basics/#Grade-projection","page":"Introduction","title":"Grade projection","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"If A  Cl(V ) is a multivector, then denote its grade k part as","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A_k  ^kV\nquadtext(grade projection)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"In code, grade projection is achieved with grade(A, k):","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A = Multivector{4,0:4}(rand(-10:10, 2^4))\ngrade(A, 3)","category":"page"},{"location":"theory/basics/#Blades-and-multivectors","page":"Introduction","title":"Blades and multivectors","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A general element in a geometric algebra is called a multivector, though there is a hierarchy of specific kinds:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"textsfbasis blades \ntextsfblades \ntextsfk-vectors \ntextsfmultivectors","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"However, GeomtricAlgebra.jl defines only two types: BasisBlade and Multivector.","category":"page"},{"location":"theory/basics/#Basis-blades","page":"Introduction","title":"Basis blades","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Let ğ¯_1  ğ¯_n be the standard orthonormal basis vectors with ğ¯_iğ¯_i  +10-1 and ğ¯_iğ¯_j = 0 for i  j. Products of the form","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"ğ¯_i_1ğ¯_i_2ğ¯_i_k","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"where i_1    i_k are the standard basis blades. Reordering the product only introduces overall factors of 1, flipping the orientation of the blade.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Scalar multiples of basis blades are represented with the BasisBlade{Sig,K,T} type, which encodes indices i_1  i_k as binary-ones. (See bits_to_indices and indices_to_bits.)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"BasisBlade{4}(42, 0b1011)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"You can generate all basis blades (of a given grade) for an algebra with basis().","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"basis(Cl(3,1), 2) # 4-dimensional Lorentzian 2-blades","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Basis blades are stored with canonically sorted indices. For example, ğ¯_2ğ¯_1 is represented as -ğ¯_1ğ¯_2:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 2 allperms=true\nv21","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"While this is always the way blades are represented internally, how they are displayed can be customised through a BasisDisplayStyle.","category":"page"},{"location":"theory/basics/#Multiplication-of-basis-blades","page":"Introduction","title":"Multiplication of basis blades","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Basis blades are closed under multiplication: a product of basis blades is a basis blade. (This motivates them having their own BasisBlade type.)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"The geometric product of ğ¯_I  ğ¯_i_1ğ¯_i_2ğ¯_i_p and ğ¯_J  ğ¯_j_1ğ¯_j_2ğ¯_j_q can be put into canonical form it two steps:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Sort the basis vectors into ğ¯_k_1ğ¯_k_2ğ¯_k_p+q where k_1    k_p + q. Each transposition of adjacent, distinct vectors results in an overall factor of -1. \nSimplify adjacent repeated vectors using the fact that ğ’—^2 = ğ’—ğ’— is a scalar.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Mathematically, this is","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"ğ¯_Iğ¯_J =\n\tunderbraceleft(sum_k  I  J ğ¯_k^2right)_textfactor from squares\n\tunderbraceoperatornamesign(operatornamesortperm(I  J))_textsign from swaps\n\t ğ¯_I  J","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"where I  J are the shared indices and I  J is the symmetric difference (the indices present in only one blade). In multi-index notation, ğ¯_I  J  ğ¯_k_1ğ¯_k_2ğ¯_k_m where I  J = k_1  k_m. operatornamesortperm(I) is the permutation that puts the indices I in ascending order.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"You can print a basis blade multiplication table using cayleytable:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"cayleytable(3)","category":"page"},{"location":"theory/basics/#Blades","page":"Introduction","title":"Blades","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"While a basis blade is a product of orthogonal basis vectors, the mathematical definition of a k-blade is a product of k distinct, mutually orthogonal vectors â€” or equivalently, a k-blade is a -product of k linearly independent vectors.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Not all blades are representable as basis blades in a given choice of basis. For example, in Cl(3) the product ğ¯_1(ğ¯_2 + ğ¯_3) is a blade (since ğ¯_1 and ğ¯_2 + ğ¯_3 are orthogonal vectors), but it is a sum of two basis blades, ğ¯_1ğ¯_2 + ğ¯_1ğ¯_3.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Thus, we cannot represent all blades with the BasisBlade type. Instead, we may use the more general Multivector type:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 3\nv1*(v2 + v3) # a blade, but not a basis blade","category":"page"},{"location":"theory/basics/#Multivectors","page":"Introduction","title":"Multivectors","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A sum of k-blades is a k-vector, or homogeneous multivector. A sum of blades of differing grade is an inhomogeneous multivector. We may use terminology such as â€œ03-vectorâ€ to mean an inhomogeneous multivector with both scalar and trivector parts.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"The Multivector{Sig,K} type represents a K-vector, which may be homogeneous (if K is an integer) or inhomogeneous (if K is a collection, such as (0, 3) or 0:3).  In all cases, the underlying data is stored in a single vector, while the type parameters define the interpretation.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 3\n4 + 7I # scalar + pseudoscalar; a (0, 3)-vector\nans.comps # underlying components vector\n1 + 2v1 + 3v23 # a general multivector\nans.comps","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"note: Note\n(Pseudo)scalars and (pseudo)vectors are always blades, but not all k-vectors are k-blades. The simplest example of a homogeneous multivector which isnâ€™t a blade requires four dimensions: the bivector ğ¯_1ğ¯_2 + ğ¯_3ğ¯_4 is not a blade since it cannot be factored as ğ’–ğ’— for vectors ğ’– and ğ’—.","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"using GeometricAlgebra","category":"page"},{"location":"theory/automorphisms/#Fundamental-Automorphisms","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Generally, operations like complex conjugation overlineAB = barAbarB or matrix transposition (AB)^ = B^A^ are useful because they preserve or reverse multiplication. (These are called automorphisms and antiautomorphisms respectively.)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Geometric algebras possess some important automorphisms: reversion tildeA, grade involution A^star and the combination of both, Clifford conjugation. These are useful unary operations which cannot be expressed in terms of simple geometric multiplication.","category":"page"},{"location":"theory/automorphisms/#Reversion","page":"Fundamental Automorphisms","title":"Reversion","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"~A or reversion(a)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Reversion tildeA is defined on multivectors A and B by the property","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"tilde(AB) = tildeBtildeA","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"and by tildeğ’– = ğ’– for vectors. Computing the reversion looks like reversing the order of the geometric product:","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"@basis 3\n~(v1*v2 + 2v1*v2*v3) == v2*v1 + 2v3*v2*v1","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Swapping orthogonal basis vectors ğ¯_iğ¯_j  ğ¯_jğ¯_i = -ğ¯_iğ¯_j introduces an overall factor of -1, and it takes binomk2 = frack(k - 1)2 swaps to reverse k many basis vectors. Thus, the reversion of a homogeneous k-vector A_k is given by","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"tildeA_k = (-1)^k(k - 1)2 A_k","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"For inhomogeneous multivectors, reversion affects each grade separately, so the result is not always simply a change in overall sign.","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Grade Reversion sign\nk (-1)^k(k - 1)2\n0 +1\n1 +1\n2 -1\n3 -1\n4 +1\n5 +1\n6 -1\n7 -1\n ","category":"page"},{"location":"theory/automorphisms/#involution","page":"Fundamental Automorphisms","title":"Grade involution","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"involution(A)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Grade involution, sometimes denoted A^star, is the operation of reflecting space through the origin, so that vectors are sent to their negative, ğ’–  -ğ’–. Involution is required to satisfy","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"mathsfinvolution(AB) = mathsfinvolution(A)mathsfinvolution(B)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"which means a k-blade of the form B = ğ¯_1  cdots  ğ¯_k gets sent to (-ğ¯_1)  cdots  (-ğ¯_k) = (-1)^k B. By linearity, for any k-vector A we have","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"mathsfinvolution(A_k) = (-1)^k A_k","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"but for inhomogeneous multivectors, involution is not always an overall change in sign.","category":"page"},{"location":"theory/automorphisms/#Clifford-conjugation","page":"Fundamental Automorphisms","title":"Clifford conjugation","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"clifford_conj(A)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"The composition of reversion and involution tildeA^star is also called the Clifford conjugate.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"using BenchmarkTools\nusing GeometricAlgebra","category":"page"},{"location":"#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"GeometricAlgebra.jl implements a flexible, performant type for multivectors in geometric (or Clifford) algebra.","category":"page"},{"location":"#Installation","page":"User Guide","title":"Installation","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"This package is not yet registered, but can be installed directly from source.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"julia> using Pkg\n\njulia> Pkg.add(url=\"https://github.com/Jollywatt/GeometricAlgebra.jl\", rev=\"v0.2.1\")\n\njulia> using GeometricAlgebra","category":"page"},{"location":"#Quick-start","page":"User Guide","title":"Quick start","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"To construct a geometric multivector from a vector of components, provide the metric signature and grade as type parameters.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"For example, a 3D Euclidean vector of grade one:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"u = Multivector{3,1}([1, -1, 0])","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"The Multivector type is simply a wrapper which associates a geometric algebra and multivector grade(s) to the underlying components vector (accessed with u.comps).","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Many multivector operations are implemented, including:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"+, -, * (geometric_prod), inv, /\ngrade for grade projection, scalar\nâˆ§ (wedge), âˆ¨ (antiwedge), â‹… (inner), âŠ™ (scalar_prod), â¨¼ (lcontract), â¨½ (rcontract)\n~ (reversion), involution, clifford_conj\nldual, rdual, hodgedual\nexp, log, trigonometric functions","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Non-euclidean metric signatures can be specified, such as Cl(3,0,1) for projective geometric algebra (PGA), or a named tuple such as (t=-1, x=+1) for custom basis vector names (see Custom basis display styles for more control).","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"For example, here is a bivector in the spacetime algebra (STA) using the (-+++) metric.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"B = Multivector{Cl(\"-+++\"),2}(1:6) # Lorentzian bivector\nexp(B)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Notice that the grades parameter of this bivector exponential is 0:2:4, for an even multivector having 8 components (instead of 16 components of a general 4D multivector).","category":"page"},{"location":"#Working-with-an-orthonormal-basis","page":"User Guide","title":"Working with an orthonormal basis","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"You can obtain an orthonormal basis for a metric signature with basis.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"v = basis(3)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"BasisBlades represent individual components of a Multivector. The macro @basis introduces basis blades into the current namespace for interactive use.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"@basis \"+---\"\n1 + 10v23 + 1000/I\n@basis (t = +1, x = -1) allperms=true\n6tx == -6xt","category":"page"},{"location":"#Code-generation","page":"User Guide","title":"Code generation","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"The @symbolicga macro may be used to generate loop- and allocation-free code from geometric algebra expressions.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"volume(v1, v2, v3) = @symbolicga 3 (v1=1, v2=1, v3=1) scalar(rdual(v1 âˆ§ v2 âˆ§ v3))\n@btime volume((1, 1, 1), (2, 3, 4), (5, 0, 5))","category":"page"},{"location":"#Custom-basis-display-styles","page":"User Guide","title":"Custom basis display styles","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"You can customise both the notation and canonical ordering with which basis blades are displayed to agree with conventions. This can be done by defining a BasisDisplayStyle(dim; kwargs...) and setting a key of GeometricAlgebra.BASIS_DISPLAY_STYLES.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Some example styles for v12 + 2v13 are:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Notation Display style BasisDisplayStyle keyword arguments\nğ_12 + 2ğ_13 ğ12 + 2ğ13 prefix=\"ğ\"\nÎ³^0Î³^1 + 2Î³^0Î³^2 Î³â°Î³Â¹ + 2Î³â°Î³Â² prefix=\"Î³\", sep=\"\", indices=\"â°Â¹Â²Â³\"\nmathrmdx  mathrmdy - 2 mathrmdz  mathrmdx dx âˆ§ dy - 2 dz âˆ§ dx prefix=\"d\", sep=\" âˆ§ \", indices=\"xyz\"","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"The last style additionally uses a custom basis blade ordering.","category":"page"},{"location":"#Custom-basis-blade-orderings","page":"User Guide","title":"Custom basis blade orderings","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"By default, multivectors are displayed with their components the same sign and in the same order as they are stored. Internally, the basis vectors in a blade are encoded in binary (see bits_to_indices and indices_to_bits.) For example:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"BasisBlade{4}(42, 0b1101)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Multivector components are stored in order of grade, then by binary value. For example, the components of a full 3D multivector correspond to the basis blades:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"GeometricAlgebra.componentbits(Multivector{3,0:3}) .|> UInt8 .|> bitstring","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"However, it can sometimes be convenient to adopt different conventions. For example, in 3D, it is common to see â€œcyclicalâ€ basis bivectors, (ğ¯_23 ğ¯_31 ğ¯_12), as these are the respective duals of (ğ¯_1 ğ¯_2 ğ¯_3). This style can be achieved as follows:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"style = BasisDisplayStyle(\n\t3, # dimension of algebra\n\tDict(2 => [[2,3], [3,1], [1,2]]), # indices and order of basis bivectors\n\tprefix=\"ğ\"\n)\nGeometricAlgebra.BASIS_DISPLAY_STYLES[3] = style;","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"The second argument of BasisDisplayStyle defines the complete list of basis blade indices for each grade.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"With this style, it is easier to â€œread offâ€ the duals of a 3D (bi)vector:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"u = Multivector{3,1}(rand(1:100, 3))\nldual(u)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Notice how the vector and dual vector components align nicely. To recover the default style:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"delete!(GeometricAlgebra.BASIS_DISPLAY_STYLES, 3)\nldual(u)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"note: Note\nBasisDisplayStyle does not affect how components are stored internally. Bear this in mind when accessing the components field of a Multivector when using a style with custom ordering.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/rotors/#Rotors","page":"Rotors","title":"Rotors","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Rotors are multivectors which describe proper rotations. The rotor formalism provides an extremely uniform, elegant and efficient description of rotations. For motivation, it is helpful to consider rotations in simpler algebras.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"In the complex plane, a complex number z  â„‚ is rotated about the origin with the mapping z  e^iÎ¸z. Similarly, a quaternion q  â„ is rotated about an axis n with q  e^n2qe^-n2. Indeed, the double-sided transformation law","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"A  e^B2Ae^-B2","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"is general to both â„‚ and â„, and in fact applies to geometric algebras of any dimension. Specifically, the rotor R = e^B2 describes a rotation in the plane spanned by the bivector B by an angle described by its magnitude.","category":"page"},{"location":"theory/rotors/#Reflections-and-orthogonal-transformations","page":"Rotors","title":"Reflections and orthogonal transformations","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"To see how the double-sided transformation law arises, note that any orthogonal transformation in n dimensions is the same as at most n reflections (the Cartanâ€“DieudonnÃ© theorem). A reflection is described in a geometric algebra by conjugation with an invertible vector. For instance, the linear map","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tA  -ğ’—Ağ’—^-1","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"reflects the multivector A along the vector ğ’— (or across the hyperplane with normal ğ’—).[1]","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"[1]: To see this, consider the case where A is a vector parallel or orthogonal to ğ’—.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"note: Note\nScaling each ğ’— by a non-zero scalar Î» does not affect the reflection. Therefore, a direct correspondence exists between reflections and normalised vectors ğ’—^2 = 1, modulo overall sign (since ğ’— and -ğ’— describe the same reflection).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"By composing reflections as above, we can obtain any orthogonal transformation, acting as","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tA  RAR^-1","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"for some R = ğ’—_1ğ’—_2ğ’—_k. The overall sign is positive for an even number of reflections (giving a proper rotation), and negative for an odd number.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Without loss of generality, we may use normalised vectors, so that the inverse is","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tR^-1 = ğ’—_k^-1cdots ğ’—_2^-1ğ’—_1^-1 = tildeR","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"since ğ’—^-1 = ğ’—. Hence, an orthogonal transformation is described by","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tA  RAtildeR","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"where R is satisfies R^-1 = tildeR.","category":"page"},{"location":"theory/rotors/#Rotor-groups","page":"Rotors","title":"Rotor groups","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"All such multivectors satisfying R^-1 = tildeR taken together form a group under the geometric product. This is called the pin group:","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tmathsfPin(p q)  big R  Cl(p q) mid RtildeR = 1 big","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"There are two â€œpinorsâ€ for every orthogonal transformation, namely +R and -R. Thus, the pin group forms a double cover of the orthogonal group mathsfO(pq).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Furthermore, the even-grade elements of mathsfPin(pq) form a subgroup, called the spin group:","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tmathsfSpin(p q)  big R  Cl_+(p q) mid RtildeR = 1 big","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"The spin group, in turn, forms a double cover of the special orthogonal group mathsfSO(p q).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Finally, the additional requirement that RtildeR = 1 defines the restricted spinor group, or the rotor group:","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tmathsfSpin^+(p q)  big R  Cl_+(p q) mid RtildeR = 1 big","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"The rotor group is a double cover of the restricted special orthogonal group mathsfSO^+(p q), which is the identity-connected part of mathsfSO(p q).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"The takeaway is that any orthogonal transformation, including reflections, rotations, and combinations of both, can be described within geometric algebra with rotors, no matter the kind of multivector being transformed, and independent of the dimension or signature of the algebra. In particular, proper rotations are described by rotors, or even multivectors satisfying RtildeR = 1.","category":"page"},{"location":"theory/rotors/#The-bivector-subalgebra","page":"Rotors","title":"The bivector subalgebra","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Bivectors play a special role as the generators of rotors. Because the even subalgebra is closed under the geometric product, the exponential","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\te^B = 1 + B + B^22 +   mathsfSpin^+","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"of a bivector B is always an even multivector, and the reverse tilde(e^B) = e^-B is the inverse. Therefore, e^B  mathsfSpin^+ is a rotor; and indeed, any rotor R  mathsfSpin^+ is of the form","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"R = e^B","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"for some bivector B.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"note: Bivector Lie algebra\nFormally, bivectors form a Lie algebra under the commutator product A  B  frac12(AB - BA). Indeed, this demonstrates a Lie groupâ€“Lie algebra correspondence between the rotor group mathsfSpin^+ and bivectors equipped with .","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#Multivector-types","page":"Docstrings","title":"Multivector types","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"types.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#GeometricAlgebra.AbstractMultivector","page":"Docstrings","title":"GeometricAlgebra.AbstractMultivector","text":"AbstractMultivector{Sig}\n\nSupertype of all elements in the geometric algebra defined by the metric signature Sig.\n\nSubtypes\n\n         AbstractMultivector{Sig}\n            /               \\\nBasisBlade{Sig,K,T}   Multivector{Sig,K,S}\n\nBasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.BasisBlade","page":"Docstrings","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig,K,T}\n\nA basis blade of grade K and scalar coefficient of type T.\n\nBasis blades are scalar multiples of wedge products of orthogonal basis vectors.\n\nnote: Note\nNot every k-blade (i.e., wedge product of k linearly independent vectors) is representable as a BasisBlade. However, every k-blade is a Multivector of grade k.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK::Int: Grade of the blade, equal to count_ones(bits), retrieved with grade().\nT: Numerical type of the scalar coefficient, retrieved with eltype().\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.BasisBlade-Union{Tuple{T}, Tuple{Sig}, Tuple{T, Unsigned}} where {Sig, T}","page":"Docstrings","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig}(bits, coeff)\n\nBasis blade with indices encoded by bits and scalar coefficient coeff.\n\nIndices are encoded in binary (e.g., vâ‚vâ‚ƒvâ‚„ has bits 0b1101).\n\nExamples\n\njulia> BasisBlade{3}(42, 0b110) # a grade 2 blade in 3 dimensions\nBasisBlade{3, 2, Int64}:\n 42 v23\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.Multivector","page":"Docstrings","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K,S} <: AbstractMultivector{Sig}\n\nA general multivector with parts of grade âˆˆ K.\n\nFor homogeneous k-vectors, the grade parameter K is an integer. Inhomogeneous multivectors may be specified with a range or tuple of grades.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK: Grade(s) present in the multivector. Can be an integer or a collection of integers (a range or tuple).\nS: Storage type of the multivector components, usually a subtype of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.Multivector-Union{Tuple{S}, Tuple{K}, Tuple{Sig}} where {Sig, K, S<:(AbstractVector)}","page":"Docstrings","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K}(comps)\n\nMultivector with grade(s) K and component vector comps.\n\nComponents are ordered first by grade, then lexicographically by bits (see componentbits).\n\nExamples\n\njulia> Multivector{3,0:3}(1:2^3)\n8-component Multivector{3, 0:3, UnitRange{Int64}}:\n 1\n 2 v1 + 3 v2 + 4 v3\n 5 v12 + 6 v13 + 7 v23\n 8 v123\n\njulia> grade(ans, 1)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 2 v1\n 3 v2\n 4 v3\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.zero-Union{Tuple{Type{Multivector{Sig, K}}}, Tuple{K}, Tuple{Sig}, Tuple{Type{Multivector{Sig, K}}, Type}} where {Sig, K}","page":"Docstrings","title":"Base.zero","text":"zero(::Type{Multivector{Sig,K,S})\nzero(::Type{Multivector{Sig,K}}, [T])\n\nMultivector of metric signature Sig and grade(s) K with components all equal to zero. If specified, the components array is of type S, or is the default array type with element type T.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.componentindex-Tuple{Union{Type{var\"#s21\"}, var\"#s21\"} where var\"#s21\"<:Multivector, BasisBlade}","page":"Docstrings","title":"GeometricAlgebra.componentindex","text":"componentindex(a::Multivector, b::Union{Unsigned,BasisBlade})\n\nIndex of the component of a.comps which corresponds to the basis blade b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.dimension-Union{Tuple{Union{Type{var\"#s21\"}, var\"#s21\"} where var\"#s21\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Docstrings","title":"GeometricAlgebra.dimension","text":"dimension(sig)\ndimension(::AbstractMultivector)\n\nThe dimension of the underlying vector space of the geometric algebra. See ncomponents for the dimension of the algebra (i.e., the number of independent components of a general multivector).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.grade-Union{Tuple{Union{Type{var\"#s21\"}, var\"#s21\"} where var\"#s21\"<:(BasisBlade{Sig, K})}, Tuple{K}, Tuple{Sig}} where {Sig, K}","page":"Docstrings","title":"GeometricAlgebra.grade","text":"grade(a)\n\nGrade or grades present in a multivector a.\n\nThe grade of a BasisBlade{Sig,K} or Multivector{Sig,K} is the second type parameter, K. In the case of a multivector, K may be an integer (if it is homogeneous) or a collection (a range or tuple of grades).\n\nSee also ishomogeneous.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.ishomogeneous-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.ishomogeneous","text":"ishomogeneous(a)\n\nWhether a is homogeneous, i.e., consists of nonzero parts of the same grade.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.isscalar-Tuple{Union{Number, ProductNode, SumNode}}","page":"Docstrings","title":"GeometricAlgebra.isscalar","text":"isscalar(a)\n\nWhether the only non-zero part of a multivector is its scalar part; a == scalar(a).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.ncomponents-Tuple{Multivector}","page":"Docstrings","title":"GeometricAlgebra.ncomponents","text":"ncomponents(::Multivector)\n\nNumber of independent components of a multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.resulting_multivector_type-Union{Tuple{Sig}, Tuple{Any, Vararg{Union{Type{var\"#s21\"}, var\"#s21\"} where var\"#s21\"<:AbstractMultivector{Sig}}}} where Sig","page":"Docstrings","title":"GeometricAlgebra.resulting_multivector_type","text":"resulting_multivector_type(f, a, b, ...)\n\nReturn a Multivector{Sig,K,S} type with parameters (signature Sig, grade(s) K and storage type S) appropriate for representing the result of f(a, b).\n\nCalls resulting_grades(f, dimension(Sig), grade(a), grade(b), ...) to determine K.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.scalar-Tuple{Union{Number, ProductNode, SumNode}}","page":"Docstrings","title":"GeometricAlgebra.scalar","text":"scalar(a) -> Number\n\nThe scalar component of a multivector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.signature-Union{Tuple{Union{Type{var\"#s21\"}, var\"#s21\"} where var\"#s21\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Docstrings","title":"GeometricAlgebra.signature","text":"signature(::AbstractMultivector{Sig}) = Sig\n\nThe metric signature type parameter of the multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Multivector-operations","page":"Docstrings","title":"Multivector operations","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"algebra.jl\", \"special.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#Base.:~-Tuple{AbstractMultivector}","page":"Docstrings","title":"Base.:~","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector a, the reversion is reversion_sign(k)*a where the sign is given by (-1)^k(k - 1)2.\n\nSee also involution and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:'á¶œ-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.:'á¶œ","text":"a'á¶œ\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:âˆ§-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.:âˆ§","text":"a âˆ§ b\nwedge(a, b, ...)\n\nWedge product of multivectors (a.k.a. the outer, exterior, progressive or alternating product, or join).\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a âˆ§ b is defined as the grade p + q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:âˆ¨-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.:âˆ¨","text":"a âˆ¨ b\nantiwedge(a, b)\n\nAnti-wedge product of multivectors (a.k.a. the regressive product or meet).\n\nThe anti-wedge product satisfies\n\nD(a  b) = (D a)  (D b)\n\nwhere D is a duality operation such as ldual, rdual or, if I^2  0, hodgedual.\n\nThe anti-wedge product is metric independent like the wedge product, but does depend on the choice of orientation (the ordering of basis vectors).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:âŠ™-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.:âŠ™","text":"a âŠ™ b\nscalar_prod(a, b) -> Number\n\nScalar part of the geometric product a*b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:â‹…-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.:â‹…","text":"a â‹… b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(absâˆ˜-, a, b). If a and b are of grades p and q respectively, then a â‹… b is defined as the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see [1] for discussion).\n\nSee also lcontract and rcontract.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:â¨¼-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.:â¨¼","text":"a â¨¼ b\nlcontract(a, b)\n\nLeft contraction of multivectors.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a â¨¼ b is defined as the grade q - p part of a*b.\n\nSee also rcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.:â¨½-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.:â¨½","text":"a â¨½ b\nrcontract(a, b)\n\nRight contraction of multivectors.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a â¨½ b is defined as the grade p - q part of a*b.\n\nSee also lcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.add!-Tuple{Multivector, Any, Unsigned}","page":"Docstrings","title":"GeometricAlgebra.add!","text":"add!(a::Multivector, b::Blade)\nadd!(a::Multivector, bits, coeff)\n\nAdd the blade coefficient to the corresponding component of a multivector, if the multivector has such a component.\n\nwarning: Warning\nIf the multivector cannot represent components of the required grade, it is returned unmodified.\n\nThis mutates and returns a if it is a mutable type, otherwise it returns a new multivector of identical type. (Thus, the blade coefficient must be convertible to the multivectorâ€™s eltype.)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.antiwedge-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.antiwedge","text":"a âˆ¨ b\nantiwedge(a, b)\n\nAnti-wedge product of multivectors (a.k.a. the regressive product or meet).\n\nThe anti-wedge product satisfies\n\nD(a  b) = (D a)  (D b)\n\nwhere D is a duality operation such as ldual, rdual or, if I^2  0, hodgedual.\n\nThe anti-wedge product is metric independent like the wedge product, but does depend on the choice of orientation (the ordering of basis vectors).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.clifford_conj-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.clifford_conj","text":"a'á¶œ\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.flipdual","page":"Docstrings","title":"GeometricAlgebra.flipdual","text":"flipdual(a)\n\nA dual of a multivector, for when the overall sign isnâ€™t important.\n\nFor a unit a::BasisBlade, the flipdual satisfies a*flipdual(a) == Â±I where Â±I is the unit pseudoscalar or its negative.\n\nThe flipdual is cheap to compute and is its own inverse. It simply flips the bits of a BasisBlade, or reverses the components vector of a Multivector.\n\nThe flipdual is metric independent (but depends on a choice of orientation, or the order of basis vectors).\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.geometric_prod-Tuple{Union{Number, ProductNode, SumNode}, Union{Number, ProductNode, SumNode}}","page":"Docstrings","title":"GeometricAlgebra.geometric_prod","text":"a * b\ngeometric_prod(a, b)\n\nGeometric product of multivectors.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.graded_multiply-Tuple{Any, Union{Number, ProductNode, SumNode}}","page":"Docstrings","title":"GeometricAlgebra.graded_multiply","text":"graded_multiply(f, a::AbstractMultivector)\n\nMultiply the grade k part of a by f(k).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.graded_prod-Tuple{Any, Union{Number, ProductNode, SumNode}, Union{Number, ProductNode, SumNode}}","page":"Docstrings","title":"GeometricAlgebra.graded_prod","text":"graded_prod(grade_selector::Function, a, b)\n\nA grade-filtered product of multivectors.\n\nTerms of the geometric product a*b are filtered according to grade_selector. For instance, if grade(a) == p and grade(b) == q, then graded_prod(f, a, b) is the grade f(p, q) part of a*b. The extends linearly to general multivectors A and B as\n\n\t(A B)  sum_pq A_p B_q_f(p q)\n\nwhere _k denotes the grade k part.\n\nThe wedge , inner  and contraction products are special cases of this product. For example, the wedge product is defined as:\n\nwedge(a, b) = graded_prod(+, a, b)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.hodgedual","page":"Docstrings","title":"GeometricAlgebra.hodgedual","text":"hodgedual(a) = ~a*I\n\nHodge dual of a multivector.\n\nThe Hodge dual is defined by\n\nH(a) = a I\n\nwhere a is the reversion of a and I is the unit pseudoscalar. For k-vectors a and b, it is alternatively defined by\n\na  H(b) = a b I\n\nwhere a b = a  b is the induced inner product on k-vectors.\n\nThe Hodge dual is metric dependent, since it involves multiplication by I.\n\nSee also invhodgedual and ldual, rdual.\n\nExamples\n\njulia> u = Multivector{3,1}(1:3)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 1 v1\n 2 v2\n 3 v3\n\njulia> hodgedual(u)\n3-component Multivector{3, 2, SVector{3, Int64}}:\n  3 v12\n -2 v13\n  1 v23\n\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.inner-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.inner","text":"a â‹… b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(absâˆ˜-, a, b). If a and b are of grades p and q respectively, then a â‹… b is defined as the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see [1] for discussion).\n\nSee also lcontract and rcontract.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.invhodgedual","page":"Docstrings","title":"GeometricAlgebra.invhodgedual","text":"invhodgedual(a)\n\nInverse of the multivector Hodge dual.\n\nIn degenerate algebras (for which I^2 = 0), the Hodge dual is not invertible. However, if a is a basis blade with a non-zero Hodge dual, then invhodgedual(hodgedual(a)) == a holds.\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.involution-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.involution","text":"involution(a)\n\nInvolute of a multivector.\n\nInvolution is an automorphism defined by reflecting through the origin: for homogeneous multivectors, involution(a) == (-1)^grade(a)*a.\n\nSee also reversion and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.lcontract-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.lcontract","text":"a â¨¼ b\nlcontract(a, b)\n\nLeft contraction of multivectors.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a â¨¼ b is defined as the grade q - p part of a*b.\n\nSee also rcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.ldual","page":"Docstrings","title":"GeometricAlgebra.ldual","text":"ldual(a)\nrdual(a)\n\nLeft and right multivector duals (a.k.a., complements). The right dual is also called the PoincarÃ© dual.\n\nFor a unit basis blade a, the duals satisfy a*rdual(a) == I == ldual(a)*a where I is the unit pseudoscalar. If dimension(a) is odd, rdual and ldual are identical and self-inverse; in general, they are inverses of each other.\n\nThe left and right duals are metric independent (but depend on a choice of orientation, or the order of basis vectors). This makes them useful in degenerate algebras where I^2 == 0, since a non-zero multivector always has a non-zero dual, even if its Hodge dual is zero.\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.outermorphism-Union{Tuple{Sig}, Tuple{AbstractMatrix, AbstractMultivector{Sig}}} where Sig","page":"Docstrings","title":"GeometricAlgebra.outermorphism","text":"outermorphism(mat, a)\n\nOutermorphism of the multivector a specified by the matrix mat.\n\nIf f is a linear map, then the outermorphism f is a linear map  satisfying f(ğ’–) = f(ğ’–) on vectors ğ’– and f(a  b) = f(a)  f(b) on general multivectors.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.rcontract-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.rcontract","text":"a â¨½ b\nrcontract(a, b)\n\nRight contraction of multivectors.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a â¨½ b is defined as the grade p - q part of a*b.\n\nSee also lcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.rdual","page":"Docstrings","title":"GeometricAlgebra.rdual","text":"ldual(a)\nrdual(a)\n\nLeft and right multivector duals (a.k.a., complements). The right dual is also called the PoincarÃ© dual.\n\nFor a unit basis blade a, the duals satisfy a*rdual(a) == I == ldual(a)*a where I is the unit pseudoscalar. If dimension(a) is odd, rdual and ldual are identical and self-inverse; in general, they are inverses of each other.\n\nThe left and right duals are metric independent (but depend on a choice of orientation, or the order of basis vectors). This makes them useful in degenerate algebras where I^2 == 0, since a non-zero multivector always has a non-zero dual, even if its Hodge dual is zero.\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.reversion-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.reversion","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector a, the reversion is reversion_sign(k)*a where the sign is given by (-1)^k(k - 1)2.\n\nSee also involution and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.sandwich_prod","page":"Docstrings","title":"GeometricAlgebra.sandwich_prod","text":"sandwich_prod(R, a)\n\nSandwich product R*a*~R of multivector a by a rotor R.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.scalar_prod-Tuple{Union{Number, ProductNode, SumNode}, Union{Number, ProductNode, SumNode}}","page":"Docstrings","title":"GeometricAlgebra.scalar_prod","text":"a âŠ™ b\nscalar_prod(a, b) -> Number\n\nScalar part of the geometric product a*b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.wedge-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.wedge","text":"a âˆ§ b\nwedge(a, b, ...)\n\nWedge product of multivectors (a.k.a. the outer, exterior, progressive or alternating product, or join).\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a âˆ§ b is defined as the grade p + q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.inv_flv_method-Tuple{Multivector}","page":"Docstrings","title":"GeometricAlgebra.inv_flv_method","text":"inv_flv_method(::AbstractMultivector)\n\nInverse of a multivector using the Faddeevâ€“LeVerrier algorithm [1].\n\nThis algorithm requires 2^d - 1 many geometric multiplications, where d is the dimension of the algebra.\n\n[1]: \"Algorithmic Computation of Multivector Inverses and Characteristic Polynomials in Non-degenerate Clifford Algebras\", [4].\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.matrix_repr","page":"Docstrings","title":"GeometricAlgebra.matrix_repr","text":"matrix_repr(a::AbstractMultivector, k=0:dim)\n\nMatrix representation of the grade k parts of a multivector.\n\nBy default, the full 2^d  2^d linear representation is used in d dimensions. Smaller representations can be used for elements in\n\nthe even subalgebra, k=0:2:dim\nthe scalar-pseudoscalar subalgebra, k=(0, dim)\n\nby restricting k to those grades.\n\nExamples\n\njulia> @basis 2\n[ Info: Defined basis blades v1, v2, v12, I in Main\n\njulia> matrix_repr(1 + 7v12)\n4Ã—4 Matrix{Int64}:\n 1   0  0  -7\n 0   1  7   0\n 0  -7  1   0\n 7   0  0   1\n\njulia> matrix_repr(1 + 7v12, (0, 2))\n2Ã—2 Matrix{Int64}:\n 1  -7\n 7   1\n\njulia> matrix_repr(v1*v2) == matrix_repr(v1)matrix_repr(v2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.try_ensure_real-Tuple{Multivector}","page":"Docstrings","title":"GeometricAlgebra.try_ensure_real","text":"try_ensure_real(a::Multivector)\n\nTries to convert a complex-valued Multivector into an equivalent real one, returning the original multivector if it failed.\n\nIf an algebra G has a commuting pseudoscalar squaring to -1, then there is a canonical map G  â„‚  G from the complexified algebra into itself given my sending the imaginary unit to the pseudoscalar.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Metric-signatures","page":"Docstrings","title":"Metric signatures","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"signatures.jl\", \"basis.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#GeometricAlgebra.Cl","page":"Docstrings","title":"GeometricAlgebra.Cl","text":"Cl(p, q=0, r=0)\n\nMetric signature where p, q and r are the number of basis vectors of norm +1, -1 and 0, respectively.\n\nExamples\n\njulia> basis(Cl(1,3))\n4-element Vector{BasisBlade{Cl(1,3), 1, Int64}}:\n 1 v1\n 1 v2\n 1 v3\n 1 v4\n\njulia> ans .^ 2\n4-element Vector{BasisBlade{Cl(1,3), 0, Int64}}:\n  1\n -1\n -1\n -1\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.Cl-Tuple{String}","page":"Docstrings","title":"GeometricAlgebra.Cl","text":"Cl(sig::String) -> Tuple\n\nShorthand for a tuple specifying a metric signature, e.g., Cl(\"-+++\") === (-1, +1, +1, +1). String may contain '+', '-' and '0'.\n\nFor readability, AbstractMultivector types with a tuple metric signature display the signature as Cl(\"...\").\n\nExamples\n\njulia> Cl(\"+++\") # 3D Euclidean metric signature\n(1, 1, 1)\n\njulia> basis(ans)\n3-element Vector{BasisBlade{Cl(\"+++\"), 1, Int64}}:\n 1 v1\n 1 v2\n 1 v3\n\njulia> Multivector{(0,-1,1,1,1),2}\nMultivector{Cl(\"0-+++\"), 2} (pretty-printed Multivector{(0, -1, 1, 1, 1), 2})\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.canonical_signature-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.canonical_signature","text":"canonical_signature(sig)\n\nCanonical tuple representation of a metric signature.\n\nExamples\n\njulia> Cl(1,3)\nCl(1,3) (pretty-printed Cl{1, 3, 0}())\n\njulia> GeometricAlgebra.canonical_signature(ans)\n(1, -1, -1, -1)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.cayleytable-Tuple","page":"Docstrings","title":"GeometricAlgebra.cayleytable","text":"cayleytable(sig, op=*)\ncayleytable(objs, op=*)\n\nDisplay a multivector multiplication table.\n\nThe first argument may be a metric signature or any vector of objects which can be combined with the binary operator op.\n\nThe keyword argument title sets the contents of the top-left cell.\n\nExamples\n\njulia> cayleytable(3)\n (â†“) * (â†’) â”‚    1 â”‚   v1     v2    v3 â”‚  v12    v13   v23 â”‚ v123\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n         1 â”‚    1 â”‚   v1     v2    v3 â”‚  v12    v13   v23 â”‚ v123\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n        v1 â”‚   v1 â”‚    1    v12   v13 â”‚   v2     v3  v123 â”‚  v23\n        v2 â”‚   v2 â”‚ -v12      1   v23 â”‚  -v1  -v123    v3 â”‚ -v13\n        v3 â”‚   v3 â”‚ -v13   -v23     1 â”‚ v123    -v1   -v2 â”‚  v12\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n       v12 â”‚  v12 â”‚  -v2     v1  v123 â”‚   -1   -v23   v13 â”‚  -v3\n       v13 â”‚  v13 â”‚  -v3  -v123    v1 â”‚  v23     -1  -v12 â”‚   v2\n       v23 â”‚  v23 â”‚ v123    -v3    v2 â”‚ -v13    v12    -1 â”‚  -v1\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€\n      v123 â”‚ v123 â”‚  v23   -v13   v12 â”‚  -v3     v2   -v1 â”‚   -1\n\njulia> cayleytable(basis((t=-1, x=1, y=1, z=1), 2), âˆ§)\n (â†“) âˆ§ (â†’) â”‚   tx     ty    xy    tz     xz    yz\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n        tx â”‚    0      0     0     0      0  txyz\n        ty â”‚    0      0     0     0  -txyz     0\n        xy â”‚    0      0     0  txyz      0     0\n        tz â”‚    0      0  txyz     0      0     0\n        xz â”‚    0  -txyz     0     0      0     0\n        yz â”‚ txyz      0     0     0      0     0\n\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.componentstype-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.componentstype","text":"componentstype(sig, N) -> Type{<:AbstractVector}\n\nThe component array type for N-component multivectors with signature sig.\n\nYou can redefine this method to customise the default array type. The fallback method returns MVector{N} for N <= 16, and Vector otherwise.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.ncomponents-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.ncomponents","text":"ncomponents(sig) = 2^dimension(sig)\nncomponents(sig, k) = binomial(dimension(sig), k)\n\nDimension of (the grade-k subspace of) the geometric algebra of metric signature sig, viewed as a vector space.\n\nIf the dimension of the underlying vector space (see dimension) in n, then the algebra is 2^n-dimensional, and its grade-k subspace binomnk-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.show_basis_blade-Tuple{IO, Any, Vector}","page":"Docstrings","title":"GeometricAlgebra.show_basis_blade","text":"show_basis_blade(io, sig, indices::Vector{Int})\n\nShow the basis blade ğ’—_iâ‚ğ’—_iâ‚– with each iâ±¼ in indices in the geometric algebra defined by sig. Methods dispatching on sig should be added to customise basis blade labels for particular algebras.\n\nExamples\n\njulia> GeometricAlgebra.show_basis_blade(stdout, (1, 1, 1), [1, 3])\nv13\n\njulia> using GeometricAlgebra: subscript\n\njulia> GeometricAlgebra.show_basis_blade(io, sig, indices) = print(io, join(\"ğ’†\".*subscript.(indices), \"âˆ§\"))\n\njulia> prod(basis(4))\nBasisBlade{âŸ¨++++âŸ©, 4, Int64} of grade 4:\n 1 ğ’†â‚âˆ§ğ’†â‚‚âˆ§ğ’†â‚ƒâˆ§ğ’†â‚„\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.show_signature-Tuple{Any, Any}","page":"Docstrings","title":"GeometricAlgebra.show_signature","text":"show_signature(io, sig)\n\nPretty-print the metric signature sig.\n\nThis is used to display the metric signature type parameter in AbstractMultivector subtypes to reduce visual noise. Methods may optionally be added for user-defined metric signatures, in a similar fashion to Base.show.\n\nExamples\n\njulia> sig = (+1,-1,-1,-1)\n(1, -1, -1, -1)\n\njulia> GeometricAlgebra.show_signature(stdout, sig)\nCl(\"+---\")\n\njulia> BasisBlade{sig}\nBasisBlade{Cl(\"+---\")} (pretty-printed BasisBlade{(1, -1, -1, -1)})\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.BASIS_DISPLAY_STYLES","page":"Docstrings","title":"GeometricAlgebra.BASIS_DISPLAY_STYLES","text":"GeometricAlgebra.BASIS_DISPLAY_STYLES\n\nA dictionary specifying the BasisDisplayStyle to use for each metric signature key.\n\nThe style for the key sig must have the same dimension as sig.\n\nTo use the default display style, remove the entry for sig with delete!(GeometricAlgebra.BASIS_DISPLAY_STYLES, sig) or remove all with empty!.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#GeometricAlgebra.BasisDisplayStyle","page":"Docstrings","title":"GeometricAlgebra.BasisDisplayStyle","text":"BasisDisplayStyle(dim, blades[, blade_order]; kwargs...)\nBasisDisplayStyle(dim, blades_and_order; kwargs...)\n\nSpecifies how basis blades are displayed and ordered. The default style for multivectors of metric signature sig can be set with GeometricAlgebra.BASIS_DISPLAY_STYLES[sig] = style.\n\ndim::Int is the dimension of the algebra (number of basis vectors).\nblades::Dict{UInt,Vector{Int}} encodes the order of basis vectors  in basis blades. E.g., 0b101 => [1, 3] is the default style.\nblade_order::Dict{Int,Vector{UInt}} specifies the order of basis blades  in a single grade. E.g., 3 => [0b011, 0b101, 0b110] is the default ordering.\nblades_and_order::Dict{Int,Vector{Int}} gives a way of specifying the previous  two mappings at once. E.g., 3 => [[1,2], [1,3], [2,3]].\n\nKeyword arguments\n\nindices=1:dim specifies the symbols used for each basis vector.\nprefix=\"v\" is the prefix string for basis blades (if sep == nothing) or for each  basis vector.\nsep=nothing is a string (e.g., \"âˆ§\") to separate each basis vector in a blade.  If sep is nothing, blades are shown as e.g., v123, whereas an empty string  results in v1v2v3.\nlabels is a dictionary allowing individual basis blades to be given custom labels.  E.g., [3,2] => \"ğ’Š\" means 4v32 is displayed as 4ğ’Š (so long as the order  0b110 => [3,2] is also specified in the blades argument â€” otherwise it would  display as the default -4v23).\n\nnote: Note\nBasisDisplayStyle only affects how multivectors are displayed. The actual internal layout of multivectors is never affected. However, the active style for sig can affect the value of basis(sig).\n\nExamples\n\njulia> Multivector{Cl(0,3),2}([3, -2, 1])\n3-component Multivector{Cl(0,3), 2, Vector{Int64}}:\n  3 v12\n -2 v13\n  1 v23\n\njulia> cyclical_style = BasisDisplayStyle(\n           3, Dict(2 => [[2,3], [3,1], [1,2]]);\n           indices = \"â‚â‚‚â‚ƒ\",\n           prefix = \"e\",\n           sep = \"\",\n           labels = Dict([1,2,3] => \"I\"),\n       );\n\njulia> GeometricAlgebra.BASIS_DISPLAY_STYLES[Cl(0,3)] = cyclical_style;\n\njulia> Multivector{Cl(0,3),2}([3, -2, 1])\n3-component Multivector{Cl(0,3), 2, Vector{Int64}}:\n 1 eâ‚‚eâ‚ƒ\n 2 eâ‚ƒeâ‚\n 3 eâ‚eâ‚‚\n\njulia> ans*rdual(ans) # pseudoscalar `eâ‚eâ‚‚eâ‚ƒ` displayed as `I`\n4-component Multivector{Cl(0,3), 1:2:3, SVector{4, Int64}}:\n 14 I\n\nTo recover the default style:\n\njulia> delete!(GeometricAlgebra.BASIS_DISPLAY_STYLES, Cl(0,3))\nIdDict{Any, BasisDisplayStyle}() \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.basis","page":"Docstrings","title":"GeometricAlgebra.basis","text":"basis(sig, k=1)\n\nVector of BasisBlades of specified grade(s) k for the geometric algebra defined by the metric signature sig. The value k=:all is a shortcut for 0:dimension(sig).\n\nThe particular basis blades returned by basis and their order reflects the signatureâ€™s BasisDisplayStyle. You can guarantee the default style by using\n\n\tBasisBlade{sig}.(1, componentbits(dimension(sig), k))\n\ninstead of basis(sig, k).\n\nSee also @basis.\n\nExamples\n\njulia> basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n 1 v1\n 1 v2\n 1 v3\n\njulia> basis(\"-+++\", 0:2:4)\n8-element Vector{BasisBlade{Cl(\"-+++\"), _A, Int64} where _A}:\n 1\n 1 v12\n 1 v13\n 1 v23\n 1 v14\n 1 v24\n 1 v34\n 1 v1234\n\njulia> basis(Cl(1,3), :all) |> sum\n16-component Multivector{Cl(1,3), 0:4, MVector{16, Int64}}:\n 1\n 1 v1 + 1 v2 + 1 v3 + 1 v4\n 1 v12 + 1 v13 + 1 v23 + 1 v14 + 1 v24 + 1 v34\n 1 v123 + 1 v124 + 1 v134 + 1 v234\n 1 v1234\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.basis-Tuple{Any, Any, Integer}","page":"Docstrings","title":"GeometricAlgebra.basis","text":"basis(sig, k, i::Integer)\n\nThe ith basis blade of grade(s) k in the geometric algebra of signature sig.\n\nIf k is a collection, indexing is done in the canonical order, with lower grades first (see componentbits).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.basis-Tuple{Type{<:Multivector}}","page":"Docstrings","title":"GeometricAlgebra.basis","text":"basis(::Type{<:Multivector})\n\nCreate a generator which iterates over basis elements of the given multivector type.\n\nExamples\n\njulia> basis(Multivector{3,1}) |> collect\n3-element Vector{Multivector{3, 1, SVector{3, Int64}}}:\n v1\n v2\n v3\n\njulia> basis(Multivector{2,0:2,Vector{Bool}}) |> collect\n4-element Vector{Multivector{2, 0:2, Vector{Bool}}}:\n (1)\n (v1)\n (v2)\n (v12)\n\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.@basis-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"GeometricAlgebra.@basis","text":"@basis sig grades=:all scalar=false pseudoscalar=:I allperms=false prefix=nothing\n\nPopulate namespace with basis blades for the geometric algebra defined by metric signature sig.\n\nVariable names are generated with show_basis_blade().\n\nKeyword arguments\n\ngrades: which grades to define basis blades for (default :all).\nscalar: whether to include the unit scalar blade (e.g., v).\npseudoscalar: alias for unit pseudoscalar (default :I). pseudoscalar=nothing defines no alias.\nallperms: include all permutations of each basis blade (e.g., define v21 as well as v12).\nprefix: prefix for basis blades names (nothing leaves default names unchanged).\n\nwarning: Warning\nThis defines 2^dimension(sig) variables with grades=:all, and more with allperms=true!\n\nExamples\n\njulia> @basis 3\n[ Info: Defined basis blades v1, v2, v3, v12, v13, v23, v123, I in Main\n\njulia> 1v2 + 3v12\n8-component Multivector{3, 0:3, SVector{8, Int64}}:\n 1 v2\n 3 v12\n\njulia> @basis \"0++\" prefix=:e\n[ Info: Defined basis blades e1, e2, e3, e12, e13, e23, e123, I in Main\n\njulia> @basis 2 allperms=true scalar=true pseudoscalar=nothing\n[ Info: Defined basis blades v, v1, v2, v12, v21 in Main\n\njulia> @basis (t=1,x=-1,y=-1,z=-1) grades=2 allperms=true\n[ Info: Defined basis blades tx, xt, ty, yt, xy, yx, tz, zt, xz, zx, yz, zy in Main\n\n\n\n\n\n","category":"macro"},{"location":"docstrings/#Logic-for-bits-and-grades","page":"Docstrings","title":"Logic for bits and grades","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"bits.jl\", \"grades.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#GeometricAlgebra.BitPermutations","page":"Docstrings","title":"GeometricAlgebra.BitPermutations","text":"BitPermutations{T}(n)\n\nInfinite iterator returning all unsigned integers of type T, in ascending order, for which Base.count_ones is n.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.bits_of_grade-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.bits_of_grade","text":"bits_of_grade(k[, dim])\n\nGenerate basis blade bits of grade k in ascending order. Yields all basis blades in the dimension dim, if given, otherwise iterates indefinitely.\n\nExamples\n\njulia> GeometricAlgebra.bits_of_grade(2, 4) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.bits_to_indices-Tuple{Unsigned}","page":"Docstrings","title":"GeometricAlgebra.bits_to_indices","text":"bits_to_indices(bits)\n\nReturn the positions of the ones in the unsigned integer bits.\n\nUsed to convert between representations of a unit basis blade. Inverse of indices_to_bits.\n\nExamples\n\njulia> GeometricAlgebra.bits_to_indices(0b1001101)\n4-element Vector{Int64}:\n 1\n 3\n 4\n 7\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.componentbits-Tuple{Any, Integer}","page":"Docstrings","title":"GeometricAlgebra.componentbits","text":"componentbits(n, k)\ncomponentbits(::Val{N}, ::Val{K})\n\nVector of bits corresponding to components of an n-dimensional Multivector of grade(s) k.\n\nBits are ordered first by grade (count_ones), then lexicographically (in ascending numerical order).\n\nPassing Val arguments calls a faster, memoized method.\n\nExamples\n\njulia> componentbits(4, 2) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\njulia> componentbits(3, 0:3) .|> UInt8 .|> bitstring\n8-element Vector{String}:\n \"00000000\"\n \"00000001\"\n \"00000010\"\n \"00000100\"\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00000111\"\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.factor_from_squares-Tuple{Any, Unsigned}","page":"Docstrings","title":"GeometricAlgebra.factor_from_squares","text":"factor_from_squares(sig, bits::Unsigned)\n\nCompute the overall factor arising from the geometric product between repeated basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.geometric_prod_factor-Tuple{Any, Unsigned, Unsigned}","page":"Docstrings","title":"GeometricAlgebra.geometric_prod_factor","text":"geometric_prod_factor(sig, a::Unsigned, b::Unsigned)\n\nThe scalar factor resulting from the geometric product between unit blades.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.indices_to_bits","page":"Docstrings","title":"GeometricAlgebra.indices_to_bits","text":"indices_to_bits(indices, T=UInt)\n\nCreate unsigned integer with bits at the positions given in the vector indices.\n\nUsed to convert between representations of a unit basis blade. Inverse of bits_to_indices.\n\nwarning: Warning\nOnly correct if maximum(indices) does not exceed number of bits in T.\n\nExamples\n\njulia> GeometricAlgebra.indices_to_bits([1, 2, 5], UInt8) |> bitstring\n\"00010011\"\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.next_bit_permutation-Tuple{Unsigned}","page":"Docstrings","title":"GeometricAlgebra.next_bit_permutation","text":"Return the smallest uint larger than the one given which has the same number of binary ones. Algorithm is Gosperâ€™s hack.\n\nExamples\n\njulia> GeometricAlgebra.next_bit_permutation(0b1011) |> bitstring\n\"00001101\"\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.reversion_sign-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.reversion_sign","text":"reversion_sign(k) = mod(k, 4) <= 1 ? +1 : -1\n\nSign from reversing a k-vector, equal to (-1)^k(k - 1)2.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.sign_from_swaps-Tuple{Unsigned, Unsigned}","page":"Docstrings","title":"GeometricAlgebra.sign_from_swaps","text":"sign_from_swaps(a::Unsigned, b::Unsigned)\n\nCompute sign flips of blade product due to transposing basis vectors into sorted order. (The full sign of the product will also depend on the basis norms.)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.getindex-Tuple{Multivector, Any}","page":"Docstrings","title":"Base.getindex","text":"a[k]\ngetindex(a::Multivector, k)\n\nGet the grade(s) k part of a multivector a if k âŠ† grade(a). The components of the resulting Multivector are a view into the components of a, so modifying a[k].comps changes a.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.componentindices-Tuple{Union{Type{var\"#s21\"}, var\"#s21\"} where var\"#s21\"<:Multivector, Integer}","page":"Docstrings","title":"GeometricAlgebra.componentindices","text":"componentindices(a, k)\n\nIndices of the components of grade(s) k in multivector a. Throws an error if k âˆ‰ grade(a).\n\nThe grade k may be an integer (returning a range) or a collection of grades (returning a vector of indices).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.grade-Tuple{AbstractMultivector, Any}","page":"Docstrings","title":"GeometricAlgebra.grade","text":"grade(::AbstractMultivector{Sig}, k) -> Multivector{Sig,k}\n\nConstruct a Multivector{Sig,k} from the grade k parts of a blade or multivector. Multiple grades may be specified with a range or tuple.\n\nThe operators + and - may be used as shortcuts for the even and odd parts, respectively.\n\nIf the return type must be inferable, use grade(a, Val(k)).\n\nExamples\n\njulia> grade(BasisBlade{3}(42, 0b101), 2)\n3-component Multivector{3, 2, SVector{3, Int64}}:\n  0 v12\n 42 v13\n  0 v23\n\njulia> a = Multivector{3, 0:3}(1:8);\n\njulia> grade(a, 1)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 2 v1\n 3 v2\n 4 v3\n\njulia> grade(a, 0:3:3)\n2-component Multivector{3, 0:3:3, SVector{2, Int64}}:\n 1\n 8 v123\n\njulia> grade(a, +) # only even grades\n4-component Multivector{3, 0:2:2, SVector{4, Int64}}:\n 1\n 5 v12 + 6 v13 + 7 v23\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.promote_grades-Tuple{Integer, Integer}","page":"Docstrings","title":"GeometricAlgebra.promote_grades","text":"promote_grades(dim, k)\n\nCanonicalize the grade type parameter k.\n\nReturns a subset of 0:dim, while attempting to normalize equivalent representations, such as 0:1:3 => 0:3 or (3, 0) => (0, 3).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.promote_grades-Tuple{Integer, OrdinalRange, Integer}","page":"Docstrings","title":"GeometricAlgebra.promote_grades","text":"promote_grades(dim, p, q, ...)\n\nReturn a suitable grade type parameter which contains the grades p âˆª q âˆª ....\n\nIn order to reduce the number of possible type parameters, the result may be larger than the exact union. Specifically, when combining different grades, promote_grades will try to return the narrowest grade(s) out of:\n\nan integer k âˆˆ 0:dim for homogeneous elements (fewest components)\n0:dim:dim, for elements in the scalar-pseudoscalar subalgebra\n0:2:dim, for elements in the even subalgebra\n0:dim, for general inhomogeneous elements (most components)\n\nExamples\n\njulia> promote_grades(4, 0:4, 2, 7)\n0:4\n\njulia> promote_grades(4, 0, 2) # even multivectors are worth representing specifically\n0:2:4\n\njulia> promote_grades(4, 0, 3) # not worth having a specific type for grades (0, 3) in 4 dims\n0:4\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.resulting_grades-NTuple{4, Any}","page":"Docstrings","title":"GeometricAlgebra.resulting_grades","text":"resulting_grades(combine, dim, p, q)\n\nNon-zero grade(s) resulting from the application of combine on dim-dimensional multivectors of grade(s) p and q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Display-methods","page":"Docstrings","title":"Display methods","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"show.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#GeometricAlgebra.show_blade-Tuple{IO, BasisBlade}","page":"Docstrings","title":"GeometricAlgebra.show_blade","text":"Display blade with parentheses surrounding coefficient if necessary.\n\nExample\n\njulia> GeometricAlgebra.show_blade(stdout, BasisBlade{(x=1,)}(1 + im, 0b1))\n(1 + 1im) x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.show_multivector-Tuple{IO, Any}","page":"Docstrings","title":"GeometricAlgebra.show_multivector","text":"show_multivector(io, a; kwargs...)\n\nDisplay multivector components in a column or inline, optionally grouping by grade.\n\nKeyword arguments\n\ninline::Bool: print on one line (default true).\ngroupgrades::Bool: visually group components by grade (default true).  If inline, prints parentheses around parts of each grade; if multiline, prints  each grade on its own line.\nshowzeros::Bool: whether to omit zero components from display.\neps::Real: supprxess components with a magnitude smaller than a threshold (default 0).\nindent::Integer: indentation width.\nparseable::Bool: use parseable style (used by repr) instead of human-readable style.\ncompact::Bool: omit unnecessary spaces, coefficients of unity, etc (default: false).\nbasis_display_style::BasisDisplayStyle: style to use to print basis blades.\n\nExamples\n\njulia> a = Multivector{2,0:2}((1:4) .^ 2);\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=false)\n 1\n 4 v1\n 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=true)\n1\n4 v1 + 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=true)\n(1) + (4 v1 + 9 v2) + (16 v12)\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=false)\n1 + 4 v1 + 9 v2 + 16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; parseable=true)\nMultivector{2, 0:2}([1, 4, 9, 16])\n\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Code-generation","page":"Docstrings","title":"Code generation","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"generated.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#GeometricAlgebra.Multivector-Union{Tuple{Symbol}, Tuple{K}, Tuple{Sig}} where {Sig, K}","page":"Docstrings","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K}(sym::Symbol)\n\nMultivector with independent symbolic components.\n\nSee also make_symbolic.\n\nExample\n\njulia> a = Multivector{3,1}(:a)\n3-component Multivector{3, 1, Vector{GeometricAlgebra.MiniCAS.ProductNode{GeometricAlgebra.MiniCAS.IndexNode{1}}}}:\n a[1] v1\n a[2] v2\n a[3] v3\n\njulia> a âŠ™ a\nGeometricAlgebra.MiniCAS.SumNode{GeometricAlgebra.MiniCAS.IndexNode{1}, Int64}:\n a[1] ^ 2 + a[2] ^ 2 + a[3] ^ 2\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.make_symbolic-Union{Tuple{K}, Tuple{Sig}, Tuple{Union{Type{var\"#s60\"}, var\"#s60\"} where var\"#s60\"<:(Multivector{Sig, K}), Any}} where {Sig, K}","page":"Docstrings","title":"GeometricAlgebra.make_symbolic","text":"make_symbolic(a, label)\n\nMultivector with symbolic components of the same type as the Multivector instance or type a.\n\nSee also symbolic_components.\n\nExample\n\njulia> GeometricAlgebra.make_symbolic(randn(Multivector{3,1}), :A)\n3-component Multivector{3, 1, Vector{GeometricAlgebra.MiniCAS.ProductNode{GeometricAlgebra.MiniCAS.IndexNode{1}}}}:\n A[1] v1\n A[2] v2\n A[3] v3\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.symbolic_components-Tuple{Symbol, Vararg{Integer}}","page":"Docstrings","title":"GeometricAlgebra.symbolic_components","text":"symbolic_components(label::Symbol, dims::Integer...)\n\nCreate an array of symbolic values of the specified shape.\n\nSee also make_symbolic.\n\nExample\n\njulia> GeometricAlgebra.symbolic_components(:a, 2, 3)\n2Ã—3 Matrix{GeometricAlgebra.MiniCAS.ProductNode{GeometricAlgebra.MiniCAS.IndexNode{2}}}:\n a[1, 1]  a[1, 2]  a[1, 3]\n a[2, 1]  a[2, 2]  a[2, 3]\n\njulia> prod(ans)\nGeometricAlgebra.MiniCAS.ProductNode{GeometricAlgebra.MiniCAS.IndexNode{2}}:\n a[1, 1] * a[1, 2] * a[1, 3] * a[2, 1] * a[2, 2] * a[2, 3]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.symbolic_multivector_eval-Tuple{Type{Expr}, Val, Function, Vararg{Any}}","page":"Docstrings","title":"GeometricAlgebra.symbolic_multivector_eval","text":"symbolic_multivector_eval(sig::Val, f::Function, args...)\n\nEvaluate f(args...) using symbolically optimised code for operations on Multivectors.\n\nThis is a generated function which first evaluates f on symbolic versions of the multivector arguments make_symbolic.(args) and then converts the symbolic result into unrolled code.\n\nIf the result is a Multivector, it is given the metric signature sig.\n\nCalling symbolic_multivector_eval(Expr, sig, f, args...) with Expr as the first argument returns the expression to be compiled.\n\nSee also @symbolic_optim.\n\nExample\n\njulia> A, B = randn(Multivector{3,0:3}, 2)\n\njulia> symbolic_multivector_eval(Expr, Val(2), geometric_prod, A, B)\n:(let a = (Multivector(args[1])).comps, b = (Multivector(args[2])).comps\n      Multivector{2, 0:2}(\n          a[1] * b[1] + -1 * (b[4] * a[4]) + b[2] * a[2] + b[3] * a[3],\n          b[3] * a[4] + b[1] * a[2] + -1 * (b[4] * a[3]) + a[1] * b[2],\n          -1 * (a[4] * b[2]) + b[4] * a[2] + b[3] * a[1] + b[1] * a[3],\n          b[3] * a[2] + a[4] * b[1] + -1 * (b[2] * a[3]) + b[4] * a[1],\n      )\n  end)\n\njulia> @btime symbolic_multivector_eval(Val(2), geometric_prod, A, B);\n  19.684 ns (2 allocations: 64 bytes)\n\njulia> @btime geometric_prod(Val(:nosym), A, B); # opt-out of symbolic optim\n  7.312 Î¼s (125 allocations: 4.67 KiB)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.symbolic_optim-Tuple{Function, Vararg{Any}}","page":"Docstrings","title":"GeometricAlgebra.symbolic_optim","text":"symbolic_optim(f, args...)\n\nEvaluate f(args...) by invoking the generated function symbolic_multivector_eval.\n\nBecause of the rules of generated functions, symbolic_multivector_eval must not call methods that may be later (re)defined. However, we still want the methods\n\ndimension(sig)\nbasis_vector_square(sig, i)\ncomponentstype(sig)\n\nto work for user-defined signature types, as part of the â€œmetric signature interfaceâ€. Since these methods may be defined in a newer world-age than symbolic_multivector_eval, we must move calls to such methods outside the generated function.\n\nTo do this, the metric signatures in args are replaced with the equivalent canonical tuple signature. (We assume that dimension(::Tuple), etc, are core functionality that wonâ€™t be modified by the user.)\n\nwarning: Warning\nIf f(args...) is a Multivector, its signature is assumed to be identical to the signature of the first AbstractMultivector argument in args. (The actual signature is lost because signatures are converted to canonical tuples.)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.use_symbolic_optim-Tuple{Any}","page":"Docstrings","title":"GeometricAlgebra.use_symbolic_optim","text":"use_symbolic_optim(sig) -> Bool\n\nWhether to use symbolic optimization in algebras of metric signature sig.\n\nBy default, this is enabled if dimension(sig) â‰¤ 8 (in many dimensions, algebraic expressions may become too unwieldy).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.@symbolic_optim-Tuple{Expr}","page":"Docstrings","title":"GeometricAlgebra.@symbolic_optim","text":"@symbolic_optim <method definition>\n\nConvert a single method definition f(args...) into two methods:\n\nThe original method f(Val(:nosym), args...), called with Val(:nosym) as the first argument. This calls the original method, without any symbolic optimization.\nAn optimized method f(args...) which calls symbolic_multivector_eval. Code for this method is generated by calling f(Val(:nosym), args...) with symbolic versions of the Multivector arguments.\n\nThis is to reduce boilerplate when writing symbolically optimized versions of each method. It only makes sense for methods with at least one AbstractMultivector argument for which the exact return type is inferable.\n\nExample\n\n# This macro call...\n@symbolic_optim foo(a, b) = (a + b)^2\n# ...is equivalent to the following two method definitions:\n\nfoo(::Val{:nosym}, a, b) = (a + b) ^ 2\n\nfunction foo(a, b)\n    if use_symbolic_optim(foo, a, b)\n        symbolic_optim(foo, Val(:nosym), a, b)\n    else\n        foo(Val(:nosym), a, b)\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"docstrings/#GeometricAlgebra.@symbolicga","page":"Docstrings","title":"GeometricAlgebra.@symbolicga","text":"@symbolicga sig mv_grades expr [result_type]\n\nEvaluate a symbolically optimised geometric algebra expression.\n\nUpon macro expansion, expr is evaluated with symbolic multivectors (specified by mv_grades) in the algebra defined by metric signature sig. The resulting symbolic expression is then compiled and executed at runtime.\n\nThe mv_grades argument is a NamedTuple where keys(mv_grades) defines the identifiers in expr to be interpreted as Multivectors, while values(mv_grades) defines their respective grades. The identifiers must exist at runtime, and can be a Multivector with matching signature/grade or any iterable with the correct number of components.\n\nIf result_type is given, then the components of the resulting multivector are converted to that type. The result type T should implement T(::Tuple), e.g., Tuple or MVector.\n\nwarning: Warning\nOperations that are not amenable to symbolic evaluation (such as exp, log, sqrt, etc) are not supported.(You may test if operations work on symbolic multivectors created with GeometricAlgebra.make_symbolic.)\n\nExamples\n\njulia> v = (1, 2, 0); R = exp(Multivector{3,2}([0, Ï€/8, 0]));\n\njulia> # Rotate a tuple (interpreted as a grade 1 vector)\n       # by a rotor, returning a tuple.\n       @symbolicga 3 (v=1, R=0:2:4) grade(R*v*~R, 1) Tuple\n(0.7071067811865475, 2.0, -0.7071067811865476)\n\n# This macro call...\n@symbolicga 3 (a=1, b=1) aâˆ§b\n# ...is equivalent to the following:\nlet a = Multivector{3, 1}(a).comps, b = Multivector{3, 1}(b).comps\n    Multivector{3, 2}(MVector(\n        a[1]*b[2] - a[2]*b[1],\n        a[1]*b[3] - a[3]*b[1],\n        a[2]*b[3] - a[3]*b[2],\n    ))\nend\n\n\n\n\n\n","category":"macro"},{"location":"docstrings/#Symbolic-utilities","page":"Docstrings","title":"Symbolic utilities","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\n\t\"MiniCAS/MiniCAS.jl\",\n\t\"MiniCAS/weightedset.jl\",\n\t\"MiniCAS/algebra.jl\",\n\t\"MiniCAS/cse.jl\",\n\t\"MiniCAS/toexpr.jl\",\n]\nModules = [MiniCAS]","category":"page"},{"location":"docstrings/#GeometricAlgebra.MiniCAS.factor-Tuple{SumNode}","page":"Docstrings","title":"GeometricAlgebra.MiniCAS.factor","text":"factor(x::SumNode)\n\nNaively collect factors that are common to all terms in x. For example, x*y + x*z becomes x*(y + z), but x^2 + 2x + 1 is left as is.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.MiniCAS.SubexprList","page":"Docstrings","title":"GeometricAlgebra.MiniCAS.SubexprList","text":"SubexprList <: AbstractDict{SubexprPointer,Expr}\n\nRepresents a directed acyclic graph of expressions as an ordered list of definitions. The last entry defines the full expression in terms of preceding subexpressions. Subexpressions are referenced with a SubexprPointer, which are the keys of the underlying OrderedDict and are pretty printed as Greek letters.\n\nSee also subexprs.\n\nExamples\n\njulia> subexprs(:(A + f(A) + g(f(A))))\nSubexprList with 3 entries:\n  Î± => :(f(A))\n  Î² => :(g(Î±))\n  Î³ => :(A + Î± + Î²)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#GeometricAlgebra.MiniCAS.cse","page":"Docstrings","title":"GeometricAlgebra.MiniCAS.cse","text":"cse(a)\n\nPerform common subexpression elimination on an Expr or value (to be converted with toexpr).\n\nReturns a let ... end block.\n\njulia> cse(:(A + f(A) + g(f(A))^2))\n:(let Î± = f(A)\n      A + Î± + g(Î±) ^ 2\n  end)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.MiniCAS.squash","page":"Docstrings","title":"GeometricAlgebra.MiniCAS.squash","text":"squash(::SubexprList, maxcount=1)::SubexprList\n\nEliminate subexpressions which are only referenced up to maxcount times substituting their definitions into subsequent expressions.\n\nExample\n\njulia> subexprs(:(A + f(A) + g(f(A))^2))\nSubexprList with 4 entries:\n  Î± => :(f(A))\n  Î² => :(g(Î±))\n  Î³ => :(Î² ^ 2)\n  Î´ => :(A + Î± + Î³)\n\njulia> squash(ans, 1)\nERROR: UndefVarError: `squash` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\nStacktrace:\n [1] top-level scope\n   @ none:1\n\njulia> squash(ans, 2)\nERROR: UndefVarError: `squash` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\nStacktrace:\n [1] top-level scope\n   @ none:1\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GeometricAlgebra.MiniCAS.subexprs-Tuple{Expr}","page":"Docstrings","title":"GeometricAlgebra.MiniCAS.subexprs","text":"subexprs(::Expr)::SubexprList\n\nFlatten an expression tree into a list of atomic expressions so that common subexpressions are identified.\n\nSee also squash.\n\nExample\n\njulia> subexprs(:(A + f(A) + g(f(A))))\nSubexprList with 3 entries:\n  Î± => :(f(A))\n  Î² => :(g(Î±))\n  Î³ => :(A + Î± + Î²)\n\njulia> toexpr(ans, pretty=true)\n:(let Î± = f(A), Î² = g(Î±)\n      A + Î± + Î²\n  end)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GeometricAlgebra.MiniCAS.toexpr-Tuple{SubexprList}","page":"Docstrings","title":"GeometricAlgebra.MiniCAS.toexpr","text":"toexpr(::SubexprList; pretty=false)\n\nRender a subexpression list as a let ... end expression.\n\nExample\n\njulia> toexpr(subexprs(:(x^2 + f(x^2))), pretty=true)\n:(let Î± = x ^ 2, Î² = f(Î±)\n      Î± + Î²\n  end)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Utilities","page":"Docstrings","title":"Utilities","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages = [\"utils.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"docstrings/#GeometricAlgebra.SingletonVector","page":"Docstrings","title":"GeometricAlgebra.SingletonVector","text":"SingletonVector(el, index, length)\n\nEfficient representation of a vector of all zeros except for the single element el at the given index.\n\n\n\n\n\n","category":"type"}]
}
