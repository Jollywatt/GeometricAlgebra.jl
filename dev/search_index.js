var documenterSearchIndex = {"docs":
[{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/products/#Wedge,-Inner-and-Other-Products","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The geometric product is the fundamental operation in geometric algebra. Together with grade projection phantomA_k, various other ‚Äúgraded products‚Äù may be defined by taking different projections of the basic product.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"To motivate this, consider a p-vector A and q-vector B. The product contains parts of every grade between the difference p - q and sum p + q in steps of two:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"AB = AB_p - q + AB_p - q + 2 +  + AB_p + q - 2 + AB_p + q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Some of these parts are often useful on their own, and so warrant their own name.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"These are summarised below, where the grade of the result is shown for each product between a p-vector and q-vector.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Name Symbol REPL shortcut Resulting grade\nscalar odot \\odot<tab> 0\nwedge  \\wedge<tab> p + q\ninner  \\cdot<tab> p - q\nleft contraction lcontr \\intprod<tab> q - p\nright contraction rcontr \\intprodr<tab> p - q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"To glance at a multiplication table for a product, you can use cayleytable. For example, left contraction in Cl(11) looks like:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"using GeometricAlgebra # hide\ncayleytable(Cl(1,1), ‚®º)","category":"page"},{"location":"theory/products/#Scalar-product","page":"Wedge, Inner and Other Products","title":"Scalar product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A ‚äô B or scalar_prod(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The scalar product is simply the scalar part of the geometric product:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  AB_0","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"It is also commonly denoted A  B or AB.","category":"page"},{"location":"theory/products/#wedge","page":"Wedge, Inner and Other Products","title":"Wedge product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A ‚àß B or wedge(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The wedge product may be defined as the highest-grade part of the geometric product. For example, if A and B are multivectors of grade p and q, respectively, then A  B = AB_p + q. This definition can be extended linearly to general multivectors as","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  sum_pq bigA_p B_qbig_p + q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Between a vector ùíñ and a multivector A, the wedge product may be written as","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"ùíñ  A = frac12(ùíñA + A^star ùíñ)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"where A^star denotes involution. Between two vectors, the wedge product is the antisymmetric part of the product:","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"ùíñ  ùíó = frac12(ùíñùíó - ùíóùíñ)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"More generally, the wedge product may be written as an antisymmetrised geometric product","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"ùíñ_1    ùíñ_k = frac1ksum_œÉ  S_k operatornamesign(œÉ) ùíñ_œÉ(1)    ùíñ_œÉ(k)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"where the sum is over all permutations œÉ of the indices 1  k. This shows the connection to antisymmetric tensors, but in practice it is much cheaper to compute the highest-grade part of the geometric product!","category":"page"},{"location":"theory/products/#Generalised-inner-product","page":"Wedge, Inner and Other Products","title":"Generalised inner product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A ‚ãÖ B or inner(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"To complement the wedge product, we also define the generalised inner product as the lowest-grade part of the geometric product. For general multivectors, define","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  sum_pq bigA_p B_qbig_p - q","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Strictly, this should not be confused with the vector inner product, although they are equivalent on vectors.","category":"page"},{"location":"theory/products/#Left-and-right-contractions","page":"Wedge, Inner and Other Products","title":"Left and right contractions","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A ‚®º B, A ‚®Ω B or lcontract(A, B), rcontract(A, B)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The left and right contractions are similar to the generalised inner product, except that they do not involve an absolute value (which arguably makes them more ‚Äòuniform‚Äô).","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"beginalign*\nA lcontr B  sum_pq bigA_p B_qbig_q - p\ntext(left contraction)\n\nA rcontr B  sum_pq bigA_p B_qbig_p - q\ntext(right contraction)\nendalign*","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"With a vector ùíñ, we have the general formulae","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"beginalign*\nùíñ lcontr A = frac12(ùíñA - A^starùíñ)\n\nA rcontr ùíñ = frac12(Aùíñ - ùíñA^star)\nendalign*","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The link with the inner product can be seen if A_p is a p-vector and B_q a q-vector, so that","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A_p  B_q = begincases A_p lcontr B_q  p  q  A_p rcontr B_q  p  q endcases","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"and indeed A  B = A lcontr B = A rcontr B = A  B if p = q.","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"Despite their similarities, the contractions are arguably better behaved than the inner product, since identities with the inner product tend to involve grade-based exceptions while identities with contractions tend to hold in full generally. (See Leo Dorst (2002) for discussion).","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"For instance, the contractions obey an associativity relation","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"(A lcontr B) rcontr C = A lcontr (B rcontr C)","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"for all multivectors A B and C, and interact nicely with the wedge product with the identities","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"beginalign*\n\t(A lcontr B)I = A  (BI)\n\tI(A rcontr B) = (IA)  B\n\tA lcontr (B lcontr C) = (A  B) lcontr C\n\t(A rcontr B) rcontr C = A rcontr (B  C)\n\tA odot (B lcontr C) = (A  B) odot C\n\t(A rcontr B) odot C = A odot (B  C)\nendalign*","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"where I is the unit pseudoscalar.[1]","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"[1]: Section 3.3, Joseph Wilson (2022)","category":"page"},{"location":"theory/products/#Other-Products","page":"Wedge, Inner and Other Products","title":"Other Products","text":"","category":"section"},{"location":"theory/products/#Commutator-product","page":"Wedge, Inner and Other Products","title":"Commutator product","text":"","category":"section"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"The commutator product is defined as","category":"page"},{"location":"theory/products/","page":"Wedge, Inner and Other Products","title":"Wedge, Inner and Other Products","text":"A  B  frac12(AB - BA)","category":"page"},{"location":"theory/references/","page":"References","title":"References","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"theory/references/","page":"References","title":"References","text":"","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"using GeometricAlgebra","category":"page"},{"location":"design/#Design-and-Internals","page":"Design and Internals","title":"Design and Internals","text":"","category":"section"},{"location":"design/#Multivector-Types","page":"Design and Internals","title":"Multivector Types","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"There are two concrete types for representing elements in a geometric algebra:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}    Multivector{Sig,K,S}","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"BasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Type parameters:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Sig: The metric signature which defines the geometric algebra. This can be any  all-bits value which satisfies the metric signature interface.\nK: The grade(s) of a multivector. For BasisBlades, this is an integer, but for Multivectors, it may be a collection (e.g., 0:3 for a general 3D multivector).\nT: The numerical type of the coefficient of a BasisBlade.\nS: The storage type of the components of a Multivector, usually an AbstractVector subtype.","category":"page"},{"location":"design/#sig","page":"Design and Internals","title":"Metric Signatures","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter Sig defines the dimension of the geometric algebra and the norms of its standard orthonormal basis vectors. Additionally, it allows various default behaviours to be customised through method definitions which dispatch on Sig, as detailed in the metric signature interface.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, the following metric signature types are implemented:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Int, defining a Euclidean metric of that dimension,\nTuple, defining the norms of each basis vector,\nNamedTuple, defining basis vector labels as well as norms,\nCl, a type resembling the notation Cl(p q r) common in literature.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> @basis 2\n[ Info: Defined basis blades v1, v2, v12, I in Main\n\njulia> basis((t=-1, x=1, y=1, z=1)) |> prod\nBasisBlade{(t = -1, x = 1, y = 1, z = 1), 4, Int64}:\n 1 txyz\n\njulia> sum(basis(Cl(\"++\"))) # shorthand for metric signature (1, 1)\n2-component Multivector{Cl(\"++\"), 1, MVector{2, Int64}}:\n 1 v1\n 1 v2","category":"page"},{"location":"design/#sig-interface","page":"Design and Internals","title":"The metric signature interface","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter may be any isbits value satisying the following interface. As well as defining the geometric algebra, the signature is used to specify basis blade labels, the default array type for multivector components, and other metadata.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Required methods Description\ndimension(sig) The dimension of the underlying vector space, or number of basis vectors.\nbasis_vector_square(sig, i) The scalar square of the ith basis vector.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Optional methods Description\nshow_signature(io, sig) Show the metric signature in a compact human-readable form.\nshow_basis_blade(io, sig, indices) Print a basis blade with the given indices (e.g., v12 or ùíÜ‚ÇÅ‚àßùíÜ‚ÇÇ).\nbits_to_indices(sig, bits) Define display order of indices for a basis blade (must also implement basis_blade_parity(sig, bits) consistently).\ncomponentstype(sig, N, T) Preferred array type for Multivector{sig} components. (E.g., Vector, MVector, SparseVector, etc.)\nuse_symbolic_optim(sig) Whether to use symbolic code generation to optimise multivector products. (Default is true for low dimensions.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Below is an example of how one might define a ‚Äúprojectivised‚Äù signature which adds a projective dimension ùêØ_0 squaring to -1 to any signature:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"import GeometricAlgebra: dimension, basis_vector_square, show_signature, show_basis_blade\n\nstruct ‚Ñô{Sig} end\n‚Ñô(sig) = ‚Ñô{sig}()\n\ndimension(::‚Ñô{Sig}) where Sig = dimension(Sig) + 1\nbasis_vector_square(::‚Ñô{Sig}, i) where Sig = i == 1 ? -1 : basis_vector_square(Sig, i - 1)\nshow_signature(io::IO, ::‚Ñô{Sig}) where Sig = print(io, \"‚Ñô($Sig)\")\n\nshow_basis_blade(io::IO, ::‚Ñô, indices::Vector) = print(io, \"v\", join(indices .- 1))\n\nbasis(‚Ñô(3)) |> sum","category":"page"},{"location":"design/#Symbolic-Algebra-and-Code-Generation","page":"Design and Internals","title":"Symbolic Algebra and Code Generation","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Thanks to the wonderful SymbolicUtils package, the same code originally written for numerical multivectors readily works with symbolic components. For example, we can compute the product of two vectors symbolically as follows:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> GeometricAlgebra.symbolic_components.([:x, :y], 3)\n2-element Vector{Vector{Any}}:\n [x[1], x[2], x[3]]\n [y[1], y[2], y[3]]\n\njulia> Multivector{3,1}.(ans)\n2-element Vector{Multivector{3, 1, Vector{Any}}}:\n x[1]v1 + x[2]v2 + x[3]v3\n y[1]v1 + y[2]v2 + y[3]v3\n\njulia> prod(ans)\n4-component Multivector{3, 0:2:2, MVector{4, Any}}:\n x[1]*y[1] + x[2]*y[2] + x[3]*y[3]\n x[1]*y[2] - x[2]*y[1] v12 + x[1]*y[3] - x[3]*y[1] v13 + x[2]*y[3] - x[3]*y[2] v23\n","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"This makes it easy to optimize multivector operations by first performing the general calculation symbolically, then converting the resulting expression into unrolled code.  (See symbolic_multivector_eval() for details.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, symbolic code generation is used for most products in up to eight dimensions (above which general algebraic expressions become unwieldy). This can be changed on a per-algebra basis by defining methods for use_symbolic_optim().","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"using GeometricAlgebra","category":"page"},{"location":"theory/basics/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"This is a brief overview of the mathematics of geometric algebra, using GeometricAlgebra.jl to explain features along the way.","category":"page"},{"location":"theory/basics/#Definition","page":"Introduction","title":"Definition","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Geometric algebra is what you get when vectors in a space are allowed to be multiplied freely,[1] with the rule that a vector ùíñ multiplied by itself gives its scalar dot product, ùíñ^2 = ùíñùíñ. What do you get when you multiply two different vectors? Well, we can simplify expressions using the relation ùíñ^2 = ùíñùíñ, along with the usual associativity ùíñ(ùíóùíò) = (ùíñùíó)ùíò and distributivity (ùíñ + ùíó)ùíò = ùíñùíò + ùíóùíò, but we may still be left with irreducible products, ùíñùíó. These are a new kind of object, distinct from scalars or vectors. These objects are called multivectors.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"[1]: More formally, Cl(V ) is the freest unital associative algebra generated by V satisfying ùíñ^2 = ùíñùíñ for all ùíñ  V.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"What this means becomes clearer after choosing a basis. In geometric algebras, orthonormal vectors ùêØ_1  ùêØ_n  V multiply according to the rules[2]","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"ùêØ_i^2 = ùêØ_iùêØ_i,\nùêØ_iùêØ_j = -ùêØ_jùêØ_i where i  j.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"The basis vector norms ùêØ_iùêØ_i may be +1, -1 or 0 depending on the inner product  on V. The elements ùêØ_iùêØ_j are bivectors (a kind of oriented plane-element), and higher grade terms ùêØ_iùêØ_jùêØ_k are trivectors, etc.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"[2]: The second rule is implied by the first, which is the defining relation ùíñ^2 = ùíñùíñ.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"In code, we may obtain an orthonormal basis with basis(sig), where sig is the metric signature parameter. We may also introduce basis variables into the global namespace with","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 3\nv1^2 # vector square gives its norm\nv2*v1 # orthogonal vectors anticommute","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"note: Terminology\nGeometric algebras are also called (real) Clifford algebras and are denoted Cl(V ) or Cl(V Q), where  has the associated quadratic form Q.Denote by Cl(n) the algebra over ‚Ñù^n where  is the standard Euclidean dot product. Write Cl(pq) for V = ‚Ñù^p + q where the inner product has p orthonormal basis vectors with norm +1 and q with norm -1, and Cl(pqr) if there are an additional r basis vectors which square to zero.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"note: Formal definition\nA formal construction of the geometric algebra Cl(V ) over a vector space V with inner product  is as the quotient algebra Cl(V )  V^ big I. Here, the tensor algebra V^ = ‚Ñù  V  (V  V)   is reduced by the ideal I which identifies all elements of the form ùíñ  ùíñ - ùíñùíñ where ùíñ  V with zero. The result is a vector space isomorphic to the exterior algebra V but with an algebraic product which mixes degrees.","category":"page"},{"location":"theory/basics/#Graded-structure","page":"Introduction","title":"Graded structure","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Geometric algebras have a graded structure: every element has a grade k  0 1 2 n or is a sum of elements of differing grades. As a vector space, Cl(V ) is the direct sum of fixed-grade subspaces","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Cl(V ) = _k=0^n ^n V = ‚Ñù  V  ^2 V    ^n V","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"where ^k V is the kth exterior power of the n-dimensional base space V.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Grade zero elements (^0V = ‚Ñù) are scalars; grade one elements (^1V = V) are vectors; and grade-k elements (^k V) are called k-vectors or homogeneous multivectors. Elements of Cl(V ) may consist of parts of differing grade, and when they do they are called (inhomogeneous) multivectors.","category":"page"},{"location":"theory/basics/#Grade-projection","page":"Introduction","title":"Grade projection","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"There are no non-zero k-vectors outside the range 0  k  n, so the subspace of ^nV contains the highest-grade objects, called pseudoscalars.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Grade Dimension of subspace Name\n0 1 scalars\n1 n vectors\n2 binomn2 bivectors\n3 binomn3 trivectors\n  \nk binomnk k-vectors\n  \nn - 1 n pseudovectors\nn 1 pseudoscalars\nall 2^n multivectors","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Notice that subspaces of grade k and n - k have the same dimension. Subspaces ^kV and their ‚Äúpseudo‚Äù-prefixed counterparts ^n - kV are associated through duality.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"If A  Cl(V ) is a multivector, then denote its grade k part as","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A_k  ^kV\nquadtext(grade projection)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"In code, grade projection is achieved with grade(A, k):","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A = Multivector{4,0:4}(rand(-10:10, 2^4))\ngrade(A, 3)","category":"page"},{"location":"theory/basics/#Blades-and-multivectors","page":"Introduction","title":"Blades and multivectors","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A general element in a geometric algebra is called a multivector, though there is a hierarchy of specific kinds:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"textsfbasis blades \ntextsfblades \ntextsfk-vectors \ntextsfmultivectors","category":"page"},{"location":"theory/basics/#Basis-blades","page":"Introduction","title":"Basis blades","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Let ùêØ_1  ùêØ_n be the standard orthonormal basis vectors with ùêØ_iùêØ_i  +10-1 and ùêØ_iùêØ_j = 0 for i  j. Products of the form","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"ùêØ_i_1ùêØ_i_2ùêØ_i_k","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"where i_1    i_k are the standard basis blades. Reordering the product only introduces overall factors of 1, flipping the orientation of the blade.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Scalar multiples of basis blades are represented with the BasisBlade{Sig,K,T} type, which encodes indices i_1  i_k as binary-ones. (See bits_to_indices and indices_to_bits.)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"BasisBlade{4}(42, 0b1011)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"You can generate all basis blades (of a given grade) for an algebra with basis().","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"basis(Cl(3,1), 2) # 4-dimensional Lorentzian 2-blades","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Basis blades are stored with canonically sorted indices. For example, ùêØ_2ùêØ_1 is represented as -ùêØ_1ùêØ_2:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 2 allperms=true\nv21","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"While this is always the way blades are represented internally, how they are displayed can be customised through a BasisDisplayStyle.","category":"page"},{"location":"theory/basics/#Multiplication-of-basis-blades","page":"Introduction","title":"Multiplication of basis blades","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Basis blades are closed under multiplication: a product of basis blades is a basis blade. (This motivates them having their own BasisBlade type.)","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"The geometric product of ùêØ_I  ùêØ_i_1ùêØ_i_2ùêØ_i_p and ùêØ_J  ùêØ_j_1ùêØ_j_2ùêØ_j_q can be put into canonical form it two steps:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Sort the basis vectors into ùêØ_k_1ùêØ_k_2ùêØ_k_p+q where k_1    k_p + q. Each transposition of adjacent, distinct vectors results in an overall factor of -1. \nSimplify adjacent repeated vectors using the fact that ùíó^2 = ùíóùíó is a scalar.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Mathematically, this is","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"ùêØ_IùêØ_J =\n\tunderbraceleft(sum_k  I  J ùêØ_k^2right)_textfactor from squares\n\tunderbraceoperatornamesign(operatornamesortperm(I  J))_textsign from swaps\n\t ùêØ_I  J","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"where I  J are the shared indices and I  J is the symmetric difference (the indices present in only one blade). In multi-index notation, ùêØ_I  J  ùêØ_k_1ùêØ_k_2ùêØ_k_m where I  J = k_1  k_m. operatornamesortperm(I) is the permutation that puts the indices I in ascending order.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"You can print a basis blade multiplication table using cayleytable:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"cayleytable(3)","category":"page"},{"location":"theory/basics/#Blades","page":"Introduction","title":"Blades","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"While a basis blade is a product of orthogonal basis vectors, the mathematical definition of a k-blade is a product of k distinct, mutually orthogonal vectors ‚Äî or equivalently, a k-blade is a -product of k linearly independent vectors.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Not all blades are representable as basis blades in a given choice of basis. For example, in Cl(3) the product ùêØ_1(ùêØ_2 + ùêØ_3) is a blade (since ùêØ_1 and ùêØ_2 + ùêØ_3 are orthogonal vectors), but it is a sum of two basis blades, ùêØ_1ùêØ_2 + ùêØ_1ùêØ_3.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"Thus, we cannot represent all blades with the BasisBlade type. Instead, we may use the more general Multivector type:","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 3\nv1*(v2 + v3) # a blade, but not a basis blade","category":"page"},{"location":"theory/basics/#Multivectors","page":"Introduction","title":"Multivectors","text":"","category":"section"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"A sum of k-blades is a k-vector, or homogeneous multivector. A sum of blades of differing grade is an inhomogeneous multivector. We may use terminology such as ‚Äú03-vector‚Äù to mean an inhomogeneous multivector with both scalar and trivector parts.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"The Multivector{Sig,K} type represents a K-vector, which may be homogeneous (if K is an integer) or inhomogeneous (if K is a collection, such as (0, 3) or 0:3).  In all cases, the underlying data is stored in a single vector, while the type parameters define the interpretation.","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"@basis 3\n4 + 7I # scalar + pseudoscalar; a (0, 3)-vector\nans.comps # underlying components vector\n1 + 2v1 + 3v23 # a general multivector\nans.comps","category":"page"},{"location":"theory/basics/","page":"Introduction","title":"Introduction","text":"note: Note\n(Pseudo)scalars and (pseudo)vectors are always blades, but not all k-vectors are k-blades. The simplest example of a homogeneous multivector which isn‚Äôt a blade requires four dimensions: the bivector ùêØ_1ùêØ_2 + ùêØ_3ùêØ_4 is not a blade since it cannot be factored as ùíñùíó for vectors ùíñ and ùíó.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Multivector-types","page":"Reference","title":"Multivector types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"types.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.AbstractMultivector","page":"Reference","title":"GeometricAlgebra.AbstractMultivector","text":"AbstractMultivector{Sig}\n\nSupertype of all elements in the geometric algebra defined by the metric signature Sig.\n\nSubtypes\n\n         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}   Multivector{Sig,K,S}                \n\nBasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.BasisBlade","page":"Reference","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig,K,T}\n\nA basis blade of grade K and scalar coefficient of type T.\n\nBasis blades are scalar multiples of wedge products of orthogonal basis vectors.\n\nnote: Note\nNot every k-blade (i.e., wedge product of k linearly independent vectors) is representable as a BasisBlade. However, every k-blade is a Multivector of grade k.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK::Int: Grade of the blade, equal to count_ones(bits), retrieved with grade().\nT: Numerical type of the scalar coefficient, retrieved with eltype().\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.BasisBlade-Union{Tuple{T}, Tuple{Sig}, Tuple{T, Unsigned}} where {Sig, T}","page":"Reference","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig}(bits, coeff)\n\nBasis blade with indices encoded by bits and scalar coefficient coeff.\n\nIndices are encoded in binary (e.g., v‚ÇÅv‚ÇÉv‚ÇÑ has bits 0b1101).\n\nExamples\n\njulia> BasisBlade{3}(42, 0b110) # a grade 2 blade in 3 dimensions\nBasisBlade{3, 2, Int64}:\n 42 v23\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.Multivector","page":"Reference","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K,S} <: AbstractMultivector{Sig}\n\nA general multivector with parts of grade ‚àà K.\n\nFor homogeneous k-vectors, the grade parameter K is an integer. Inhomogeneous multivectors may be specified with a range or tuple of grades.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK: Grade(s) present in the multivector. Can be an integer or a collection of integers (a range or tuple).\nS: Storage type of the multivector components, usually a subtype of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.Multivector-Union{Tuple{S}, Tuple{K}, Tuple{Sig}} where {Sig, K, S}","page":"Reference","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K}(comps)\n\nMultivector with grade(s) K and component vector comps.\n\nComponents are ordered first by grade, then lexicographically by bits (see componentbits).\n\nExamples\n\njulia> Multivector{3,0:3}(1:2^3)\n8-component Multivector{3, 0:3, UnitRange{Int64}}:\n 1\n 2 v1 + 3 v2 + 4 v3\n 5 v12 + 6 v13 + 7 v23\n 8 v123\n\njulia> grade(ans, 1)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 2 v1\n 3 v2\n 4 v3\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.zero-Union{Tuple{Type{Multivector{Sig, K}}}, Tuple{K}, Tuple{Sig}, Tuple{Type{Multivector{Sig, K}}, Type}} where {Sig, K}","page":"Reference","title":"Base.zero","text":"zero(::Type{Multivector{Sig,K,S})\nzero(::Type{Multivector{Sig,K}}, [T])\n\nMultivector of metric signature Sig and grade(s) K with components all equal to zero. If specified, the components array is of type S, or is the default array type with element type T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentindex-Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:Multivector, BasisBlade}","page":"Reference","title":"GeometricAlgebra.componentindex","text":"componentindex(a::Multivector, b::Union{Unsigned,BasisBlade})\n\nIndex of the component of a.comps which corresponds to the basis blade b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.dimension-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.dimension","text":"dimension(sig)\ndimension(::AbstractMultivector)\n\nThe dimension of the underlying vector space of the geometric algebra. See ncomponents for the dimension of the algebra (i.e., the number of independent components of a general multivector).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.grade-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:(BasisBlade{Sig, K})}, Tuple{K}, Tuple{Sig}} where {Sig, K}","page":"Reference","title":"GeometricAlgebra.grade","text":"grade(a)\n\nGrade or grades present in a multivector a.\n\nThe grade of a BasisBlade{Sig,K} or Multivector{Sig,K} is the second type parameter, K. In the case of a multivector, K may be an integer (if it is homogeneous) or a collection (a range or tuple of grades).\n\nSee also ishomogeneous.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ishomogeneous-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.ishomogeneous","text":"ishomogeneous(a)\n\nWhether a is homogeneous, i.e., consists of nonzero parts of the same grade.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.isscalar-Tuple{Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.isscalar","text":"isscalar(a)\n\nWhether the only non-zero part of a multivector is its scalar part; a == scalar(a).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ncomponents-Tuple{Multivector}","page":"Reference","title":"GeometricAlgebra.ncomponents","text":"ncomponents(::Multivector)\n\nNumber of independent components of a multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.resulting_multivector_type-Union{Tuple{Sig}, Tuple{Any, Vararg{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}}} where Sig","page":"Reference","title":"GeometricAlgebra.resulting_multivector_type","text":"resulting_multivector_type(f, a, b, ...)\n\nReturn a Multivector{Sig,K,S} type with parameters (signature Sig, grade(s) K and storage type S) appropriate for representing the result of f(a, b).\n\nCalls resulting_grades(f, dimension(Sig), grade(a), grade(b), ...) to determine K.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.scalar-Tuple{Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.scalar","text":"scalar(a) -> Number\n\nThe scalar component of a multivector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.signature-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.signature","text":"signature(::AbstractMultivector{Sig}) = Sig\n\nThe metric signature type parameter of the multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Multivector-operations","page":"Reference","title":"Multivector operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"algebra.jl\", \"special.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#Base.:~-Tuple{AbstractMultivector}","page":"Reference","title":"Base.:~","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector a, the reversion is reversion_sign(k)*a where the sign is given by (-1)^k(k - 1)2.\n\nSee also involution and clifford_conj.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:'·∂ú-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.:'·∂ú","text":"a'·∂ú\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:‚àß-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:‚àß","text":"a ‚àß b\nwedge(a, b)\n\nWedge product of multivectors (a.k.a. the outer, exterior, progressive or alternating product, or join).\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a ‚àß b is defined as the grade p + q part of a*b.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:‚à®-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:‚à®","text":"a ‚à® b\nantiwedge(a, b)\n\nAnti-wedge product of multivectors (a.k.a. the regressive product or meet).\n\nThe anti-wedge product satisfies\n\nD(a  b) = (D a)  (D b)\n\nwhere D is a duality operation such as ldual, rdual or, if I^2  0, hodgedual.\n\nThe anti-wedge product is metric independent like the wedge product, but does depend on the choice of orientation (the ordering of basis vectors).\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:‚äô-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:‚äô","text":"a ‚äô b\nscalar_prod(a, b) -> Number\n\nScalar part of the geometric product a*b.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:‚ãÖ-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:‚ãÖ","text":"a ‚ãÖ b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(abs‚àò-, a, b). If a and b are of grades p and q respectively, then a ‚ãÖ b is defined as the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see Leo Dorst (2002) for discussion).\n\nSee also lcontract and rcontract.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:‚®º-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:‚®º","text":"a ‚®º b\nlcontract(a, b)\n\nLeft contraction of multivectors.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a ‚®º b is defined as the grade q - p part of a*b.\n\nSee also rcontract and inner.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:‚®Ω-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:‚®Ω","text":"a ‚®Ω b\nrcontract(a, b)\n\nRight contraction of multivectors.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a ‚®Ω b is defined as the grade p - q part of a*b.\n\nSee also lcontract and inner.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.add!-Tuple{Multivector, Any, Unsigned}","page":"Reference","title":"GeometricAlgebra.add!","text":"add!(a::Multivector, b::Blade)\nadd!(a::Multivector, bits, coeff)\n\nAdd the blade coefficient to the corresponding component of a multivector, if the multivector has such a component.\n\nwarning: Warning\nIf the multivector cannot represent components of the required grade, it is returned unmodified.\n\nThis mutates and returns a if it is a mutable type, otherwise it returns a new multivector of identical type. (Thus, the blade coefficient must be convertible to the multivector‚Äôs eltype.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.antiwedge-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.antiwedge","text":"a ‚à® b\nantiwedge(a, b)\n\nAnti-wedge product of multivectors (a.k.a. the regressive product or meet).\n\nThe anti-wedge product satisfies\n\nD(a  b) = (D a)  (D b)\n\nwhere D is a duality operation such as ldual, rdual or, if I^2  0, hodgedual.\n\nThe anti-wedge product is metric independent like the wedge product, but does depend on the choice of orientation (the ordering of basis vectors).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.clifford_conj-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.clifford_conj","text":"a'·∂ú\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.flipdual","page":"Reference","title":"GeometricAlgebra.flipdual","text":"flipdual(a)\n\nA dual of a multivector, for when the overall sign isn‚Äôt important.\n\nFor a unit a::BasisBlade, the flipdual satisfies a*flipdual(a) == ¬±I where ¬±I is the unit pseudoscalar or its negative.\n\nThe flipdual is cheap to compute and is its own inverse. It simply flips the bits of a BasisBlade, or reverses the components vector of a Multivector.\n\nThe flipdual is metric independent (but depends on a choice of orientation, or the order of basis vectors).\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.geometric_prod-Tuple{Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.geometric_prod","text":"a * b\ngeometric_prod(a, b)\n\nGeometric product of multivectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.graded_multiply-Tuple{Any, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.graded_multiply","text":"graded_multiply(f, a::AbstractMultivector)\n\nMultiply the grade k part of a by f(k).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.graded_prod-Tuple{Any, Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.graded_prod","text":"graded_prod(grade_selector::Function, a, b)\n\nA \"graded\" product of multivectors, generalising the wedge , inner  and contraction products. For example, the wedge product is defined as:\n\nwedge(a, b) = graded_prod(+, a, b)\n\nIf grade(a) == p and grade(b) == q, then graded_prod(f, a, b) is the grade f(p, q) part of a*b. The definition extends linearly to general multivectors A and B as\n\n\t(A B)  sum_pq A_p B_q_f(p q)\n\nwhere _k denotes the grade k part.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.hodgedual","page":"Reference","title":"GeometricAlgebra.hodgedual","text":"hodgedual(a) = ~a*I\n\nHodge dual of a multivector.\n\nThe Hodge dual is defined by\n\nH(a) = a I\n\nwhere a is the reversion of a and I is the unit pseudoscalar. For k-vectors a and b, it is alternatively defined by\n\na  H(b) = a b I\n\nwhere a b = a  b is the induced inner product on k-vectors.\n\nThe Hodge dual is metric dependent, since it involves multiplication by I.\n\nSee also invhodgedual and ldual, rdual.\n\nExamples\n\njulia> u = Multivector{3,1}(1:3)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 1 v1\n 2 v2\n 3 v3\n\njulia> hodgedual(u)\n3-component Multivector{3, 2, MVector{3, Int64}}:\n  3 v12\n -2 v13\n  1 v23\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.inner-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.inner","text":"a ‚ãÖ b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(abs‚àò-, a, b). If a and b are of grades p and q respectively, then a ‚ãÖ b is defined as the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see Leo Dorst (2002) for discussion).\n\nSee also lcontract and rcontract.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.invhodgedual","page":"Reference","title":"GeometricAlgebra.invhodgedual","text":"invhodgedual(a)\n\nInverse of the multivector Hodge dual.\n\nIn degenerate algebras (for which I^2 = 0), the Hodge dual is not invertible. However, if a is a basis blade with a non-zero Hodge dual, then invhodgedual(hodgedual(a)) == a holds.\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.involution-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.involution","text":"involution(a)\n\nInvolute of a multivector.\n\nInvolution is an automorphism defined by reflecting through the origin: for homogeneous multivectors, involution(a) == (-1)^grade(a)*a.\n\nSee also reversion and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.lcontract-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.lcontract","text":"a ‚®º b\nlcontract(a, b)\n\nLeft contraction of multivectors.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a ‚®º b is defined as the grade q - p part of a*b.\n\nSee also rcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ldual","page":"Reference","title":"GeometricAlgebra.ldual","text":"ldual(a)\nrdual(a)\n\nLeft and right multivector duals (a.k.a., complements). The right dual is also called the Poincar√© dual.\n\nFor a unit basis blade a, the duals satisfy a*rdual(a) == I == ldual(a)*a where I is the unit pseudoscalar. If dimension(a) is odd, rdual and ldual are identical and self-inverse; in general, they are inverses of each other.\n\nThe left and right duals are metric independent (but depend on a choice of orientation, or the order of basis vectors). This makes them useful in degenerate algebras where I^2 == 0, since a non-zero multivector always has a non-zero dual, even if its Hodge dual is zero.\n\nSee also hodgedual.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.outermorphism-Union{Tuple{Sig}, Tuple{AbstractMatrix, AbstractMultivector{Sig}}} where Sig","page":"Reference","title":"GeometricAlgebra.outermorphism","text":"outermorphism(mat, a)\n\nOutermorphism of the multivector a specified by the matrix mat.\n\nIf f is a linear map, then the outermorphism f is a linear map  satisfying f(ùíñ) = f(ùíñ) on vectors ùíñ and f(a  b) = f(a)  f(b) on general multivectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.rcontract-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.rcontract","text":"a ‚®Ω b\nrcontract(a, b)\n\nRight contraction of multivectors.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a ‚®Ω b is defined as the grade p - q part of a*b.\n\nSee also lcontract and inner.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.rdual","page":"Reference","title":"GeometricAlgebra.rdual","text":"ldual(a)\nrdual(a)\n\nLeft and right multivector duals (a.k.a., complements). The right dual is also called the Poincar√© dual.\n\nFor a unit basis blade a, the duals satisfy a*rdual(a) == I == ldual(a)*a where I is the unit pseudoscalar. If dimension(a) is odd, rdual and ldual are identical and self-inverse; in general, they are inverses of each other.\n\nThe left and right duals are metric independent (but depend on a choice of orientation, or the order of basis vectors). This makes them useful in degenerate algebras where I^2 == 0, since a non-zero multivector always has a non-zero dual, even if its Hodge dual is zero.\n\nSee also hodgedual.\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.reversion-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.reversion","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector a, the reversion is reversion_sign(k)*a where the sign is given by (-1)^k(k - 1)2.\n\nSee also involution and clifford_conj.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.sandwich_prod","page":"Reference","title":"GeometricAlgebra.sandwich_prod","text":"sandwich_prod(R, a)\n\nSandwich product R*a*~R of multivector a by a rotor R.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.scalar_prod-Tuple{Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.scalar_prod","text":"a ‚äô b\nscalar_prod(a, b) -> Number\n\nScalar part of the geometric product a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.wedge-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.wedge","text":"a ‚àß b\nwedge(a, b)\n\nWedge product of multivectors (a.k.a. the outer, exterior, progressive or alternating product, or join).\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a ‚àß b is defined as the grade p + q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.matrix_repr","page":"Reference","title":"GeometricAlgebra.matrix_repr","text":"matrix_repr(a::AbstractMultivector, k=0:dim)\n\nMatrix representation of the grade k parts of a multivector.\n\nBy default, the full 2^d  2^d linear representation is used in d dimensions. Smaller representations can be used for elements in\n\nthe even subalgebra, k=0:2:dim\nthe scalar-pseudoscalar subalgebra, k=(0, dim)\n\nby restricting k to those grades.\n\nExamples\n\njulia> @basis 2\n[ Info: Defined basis blades v1, v2, v12, I in Main\n\njulia> matrix_repr(1 + 7v12)\n4√ó4 Matrix{Int64}:\n 1   0  0  -7\n 0   1  7   0\n 0  -7  1   0\n 7   0  0   1\n\njulia> matrix_repr(1 + 7v12, (0, 2))\n2√ó2 Matrix{Int64}:\n 1  -7\n 7   1\n\njulia> matrix_repr(v1*v2) == matrix_repr(v1)matrix_repr(v2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#Metric-Signatures","page":"Reference","title":"Metric Signatures","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"signatures.jl\", \"basis.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.Cl","page":"Reference","title":"GeometricAlgebra.Cl","text":"Cl(p, q=0, r=0)\n\nMetric signature where p, q and r are the number of basis vectors of norm +1, -1 and 0, respectively.\n\nExamples\n\njulia> basis(Cl(1,3))\n4-element Vector{BasisBlade{Cl(1,3), 1, Int64}}:\n 1 v1\n 1 v2\n 1 v3\n 1 v4\n\njulia> ans .^ 2\n4-element Vector{BasisBlade{Cl(1,3), 0, Int64}}:\n  1\n -1\n -1\n -1\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.Cl-Tuple{String}","page":"Reference","title":"GeometricAlgebra.Cl","text":"Cl(sig::String) -> Tuple\n\nShorthand for a tuple specifying a metric signature, e.g., Cl(\"-+++\") === (-1, +1, +1, +1). String may contain '+', '-' and '0'.\n\nExample\n\njulia> Cl(\"+++\") # 3D Euclidean metric signature\n(1, 1, 1)\n\njulia> basis(ans)\n3-element Vector{BasisBlade{Cl(\"+++\"), 1, Int64}}:\n 1 v1\n 1 v2\n 1 v3\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.cayleytable-Tuple","page":"Reference","title":"GeometricAlgebra.cayleytable","text":"cayleytable(sig, op=*)\ncayleytable(objs, op=*)\n\nDisplay a multivector multiplication table.\n\nThe first argument may be a metric signature or any vector of objects which can be combined with the binary operator op.\n\nThe keyword argument title sets the contents of the top-left cell.\n\nExamples\n\njulia> cayleytable(3)\n (‚Üì) * (‚Üí) ‚îÇ    1 ‚îÇ   v1     v2    v3 ‚îÇ  v12    v13   v23 ‚îÇ v123\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n         1 ‚îÇ    1 ‚îÇ   v1     v2    v3 ‚îÇ  v12    v13   v23 ‚îÇ v123\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        v1 ‚îÇ   v1 ‚îÇ    1    v12   v13 ‚îÇ   v2     v3  v123 ‚îÇ  v23\n        v2 ‚îÇ   v2 ‚îÇ -v12      1   v23 ‚îÇ  -v1  -v123    v3 ‚îÇ -v13\n        v3 ‚îÇ   v3 ‚îÇ -v13   -v23     1 ‚îÇ v123    -v1   -v2 ‚îÇ  v12\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n       v12 ‚îÇ  v12 ‚îÇ  -v2     v1  v123 ‚îÇ   -1   -v23   v13 ‚îÇ  -v3\n       v13 ‚îÇ  v13 ‚îÇ  -v3  -v123    v1 ‚îÇ  v23     -1  -v12 ‚îÇ   v2\n       v23 ‚îÇ  v23 ‚îÇ v123    -v3    v2 ‚îÇ -v13    v12    -1 ‚îÇ  -v1\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n      v123 ‚îÇ v123 ‚îÇ  v23   -v13   v12 ‚îÇ  -v3     v2   -v1 ‚îÇ   -1\n\njulia> cayleytable(basis((t=-1, x=1, y=1, z=1), 2), ‚àß)\n (‚Üì) ‚àß (‚Üí) ‚îÇ   tx     ty    xy    tz     xz    yz\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        tx ‚îÇ    0      0     0     0      0  txyz\n        ty ‚îÇ    0      0     0     0  -txyz     0\n        xy ‚îÇ    0      0     0  txyz      0     0\n        tz ‚îÇ    0      0  txyz     0      0     0\n        xz ‚îÇ    0  -txyz     0     0      0     0\n        yz ‚îÇ txyz      0     0     0      0     0\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentstype-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.componentstype","text":"componentstype(sig, N) -> Type{<:AbstractVector}\n\nThe component array type for N-component multivectors with signature sig.\n\nYou can redefine this method to customise the default array type. The fallback method returns MVector{N} for N <= 16, and Vector otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ncomponents-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.ncomponents","text":"ncomponents(sig) = 2^dimension(sig)\nncomponents(sig, k) = binomial(dimension(sig), k)\n\nDimension of (the grade-k subspace of) the geometric algebra of metric signature sig, viewed as a vector space.\n\nIf the dimension of the underlying vector space (see dimension) in n, then the algebra is 2^n-dimensional, and its grade-k subspace binomnk-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_basis_blade-Tuple{IO, Any, Vector}","page":"Reference","title":"GeometricAlgebra.show_basis_blade","text":"show_basis_blade(io, sig, indices::Vector{Int})\n\nShow the basis blade ùíó_i‚ÇÅùíó_i‚Çñ with each i‚±º in indices in the geometric algebra defined by sig. Methods dispatching on sig should be added to customise basis blade labels for particular algebras.\n\nExamples\n\njulia> GeometricAlgebra.show_basis_blade(stdout, (1, 1, 1), [1, 3])\nv13\n\njulia> using GeometricAlgebra: subscript\n\njulia> GeometricAlgebra.show_basis_blade(io, sig, indices) = print(io, join(\"ùíÜ\".*subscript.(indices), \"‚àß\"))\n\njulia> prod(basis(4))\nBasisBlade{‚ü®++++‚ü©, 4, Int64} of grade 4:\n 1 ùíÜ‚ÇÅ‚àßùíÜ‚ÇÇ‚àßùíÜ‚ÇÉ‚àßùíÜ‚ÇÑ\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_signature-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.show_signature","text":"show_signature(io, sig)\n\nPretty-print the metric signature sig.\n\nThis is used to display the metric signature type parameter in AbstractMultivector subtypes to reduce visual noise. Methods may optionally be added for user-defined metric signatures, in a similar fashion to Base.show.\n\nExamples\n\njulia> sig = (+1,-1,-1,-1)\n(1, -1, -1, -1)\n\njulia> GeometricAlgebra.show_signature(stdout, sig)\nCl(\"+---\")\n\njulia> BasisBlade{sig}\nBasisBlade{Cl(\"+---\")} (pretty-printed BasisBlade{(1, -1, -1, -1)})\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.BASIS_DISPLAY_STYLES","page":"Reference","title":"GeometricAlgebra.BASIS_DISPLAY_STYLES","text":"GeometricAlgebra.BASIS_DISPLAY_STYLES\n\nA dictionary specifying the BasisDisplayStyle to use for each metric signature key.\n\nThe style for the key sig must have the same dimension as sig.\n\nTo use the default display style, remove the entry for sig with delete!(GeometricAlgebra.BASIS_DISPLAY_STYLES, sig) or remove all with empty!.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#GeometricAlgebra.BasisDisplayStyle","page":"Reference","title":"GeometricAlgebra.BasisDisplayStyle","text":"BasisDisplayStyle(dim, blades[, blade_order]; kwargs...)\nBasisDisplayStyle(dim, blades_and_order; kwargs...)\n\nSpecifies how basis blades are displayed and ordered. The default style for multivectors of metric signature sig can be set with GeometricAlgebra.BASIS_DISPLAY_STYLES[sig] = style.\n\ndim::Int is the dimension of the algebra (number of basis vectors).\nblades::Dict{UInt,Vector{Int}} encodes the order of basis vectors  in basis blades. E.g., 0b101 => [1, 3] is the default style.\nblade_order::Dict{Int,Vector{UInt}} specifies the order of basis blades  in a single grade. E.g., 3 => [0b011, 0b101, 0b110] is the default ordering.\nblades_and_order::Dict{Int,Vector{Int}} gives a way of specifying the previous  two mappings at once. E.g., 3 => [[1,2], [1,3], [2,3]].\n\nKeyword arguments\n\nindices=1:dim specifies the symbols used for each basis vector.\nprefix=\"v\" is the prefix string for basis blades (if sep == nothing) or for each  basis vector.\nsep=nothing is a string (e.g., \"‚àß\") to separate each basis vector in a blade.  If sep is nothing, blades are shown as e.g., v123, whereas an empty string  results in v1v2v3.\nlabels is a dictionary allowing individual basis blades to be given custom labels.  E.g., [3,2] => \"ùíä\" means 4v32 is displayed as 4ùíä (so long as the order  0b110 => [3,2] is also specified in the blades argument ‚Äî otherwise it would  display as the default -4v23).\n\nnote: Note\nBasisDisplayStyle only affects how multivectors are displayed. The actual internal layout of multivectors is never affected. However, the active style for sig can affect the value of basis(sig).\n\nExamples\n\njulia> Multivector{Cl(0,3),2}([3, -2, 1])\n3-component Multivector{Cl(0,3), 2, Vector{Int64}}:\n  3 v12\n -2 v13\n  1 v23\n\njulia> cyclical_style = BasisDisplayStyle(\n           3, Dict(2 => [[2,3], [3,1], [1,2]]);\n           indices = \"‚ÇÅ‚ÇÇ‚ÇÉ\",\n           prefix = \"e\",\n           sep = \"\",\n           labels = Dict([1,2,3] => \"I\"),\n       );\n\njulia> GeometricAlgebra.BASIS_DISPLAY_STYLES[Cl(0,3)] = cyclical_style;\n\njulia> Multivector{Cl(0,3),2}([3, -2, 1])\n3-component Multivector{Cl(0,3), 2, Vector{Int64}}:\n 1 e‚ÇÇe‚ÇÉ\n 2 e‚ÇÉe‚ÇÅ\n 3 e‚ÇÅe‚ÇÇ\n\njulia> ans*rdual(ans) # pseudoscalar `e‚ÇÅe‚ÇÇe‚ÇÉ` displayed as `I`\n4-component Multivector{Cl(0,3), 1:2:3, MVector{4, Int64}}:\n 14 I\n\nTo recover the default style:\n\njulia> delete!(GeometricAlgebra.BASIS_DISPLAY_STYLES, Cl(0,3))\nIdDict{Any, BasisDisplayStyle}() \n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.basis","page":"Reference","title":"GeometricAlgebra.basis","text":"basis(sig, k=1)\n\nVector of basis blades of specified grade(s) k for the geometric algebra defined by the metric signature sig. The value k=:all is a shortcut for 0:dimension(sig).\n\nThe particular basis blades returned by basis and their order reflects the signature‚Äôs BasisDisplayStyle. You can guarantee the default style by using\n\n\tBasisBlade{sig}.(1, componentbits(dimension(sig), k))\n\ninstead of basis(sig, k).\n\nSee also @basis.\n\nExamples\n\njulia> basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n 1 v1\n 1 v2\n 1 v3\n\njulia> basis(\"-+++\", 0:2:4)\n8-element Vector{BasisBlade{Cl(\"-+++\"), _A, Int64} where _A}:\n 1\n 1 v12\n 1 v13\n 1 v23\n 1 v14\n 1 v24\n 1 v34\n 1 v1234\n\njulia> basis(Cl(1,3), :all) |> sum\n16-component Multivector{Cl(1,3), 0:4, MVector{16, Int64}}:\n 1\n 1 v1 + 1 v2 + 1 v3 + 1 v4\n 1 v12 + 1 v13 + 1 v23 + 1 v14 + 1 v24 + 1 v34\n 1 v123 + 1 v124 + 1 v134 + 1 v234\n 1 v1234\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.basis-Tuple{Type{<:Multivector}}","page":"Reference","title":"GeometricAlgebra.basis","text":"basis(::Type{<:Multivector})\n\nCreate a generator which iterates over basis elements of the given multivector type.\n\nExamples\n\njulia> basis(Multivector{3,1}) |> collect\n3-element Vector{Multivector{3, 1, MVector{3, Int64}}}:\n v1\n v2\n v3\n\njulia> basis(Multivector{2,0:2,Vector{Bool}}) |> collect\n4-element Vector{Multivector{2, 0:2, Vector{Bool}}}:\n (1)\n (v1)\n (v2)\n (v12)\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.@basis-Tuple{Any, Vararg{Any}}","page":"Reference","title":"GeometricAlgebra.@basis","text":"@basis sig grades=:all scalar=false pseudoscalar=:I allperms=false prefix=nothing\n\nPopulate namespace with basis blades for the geometric algebra defined by metric signature sig.\n\nVariable names are generated with show_basis_blade().\n\nKeyword arguments\n\ngrades: which grades to define basis blades for (default :all).\nscalar: whether to include the unit scalar blade (e.g., v).\npseudoscalar: alias for unit pseudoscalar (default :I). pseudoscalar=nothing defines no alias.\nallperms: include all permutations of each basis blade (e.g., define v21 as well as v12).\nprefix: prefix for basis blades names (nothing leaves default names unchanged).\n\nwarning: Warning\nThis defines 2^dimension(sig) variables with grades=:all, and more with allperms=true!\n\nExamples\n\njulia> @basis 3\n[ Info: Defined basis blades v1, v2, v3, v12, v13, v23, v123, I in Main\n\njulia> 1v2 + 3v12\n8-component Multivector{3, 0:3, MVector{8, Int64}}:\n 1 v2\n 3 v12\n\njulia> @basis \"0++\" prefix=:e\n[ Info: Defined basis blades e1, e2, e3, e12, e13, e23, e123, I in Main\n\njulia> @basis 2 allperms=true scalar=true pseudoscalar=nothing\n[ Info: Defined basis blades v, v1, v2, v12, v21 in Main\n\njulia> @basis (t=1,x=-1,y=-1,z=-1) grades=2 allperms=true\n[ Info: Defined basis blades tx, xt, ty, yt, xy, yx, tz, zt, xz, zx, yz, zy in Main\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Logic-for-bits-and-grades","page":"Reference","title":"Logic for bits and grades","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"bits.jl\", \"grades.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.BitPermutations","page":"Reference","title":"GeometricAlgebra.BitPermutations","text":"BitPermutations{T}(n)\n\nInfinite iterator returning all unsigned integers of type T, in ascending order, for which Base.count_ones is n.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.bits_of_grade-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.bits_of_grade","text":"bits_of_grade(k[, dim])\n\nGenerate basis blade bits of grade k in ascending order. Yields all basis blades in the dimension dim, if given, otherwise iterates indefinitely.\n\nExamples\n\njulia> GeometricAlgebra.bits_of_grade(2, 4) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.bits_to_indices-Tuple{Unsigned}","page":"Reference","title":"GeometricAlgebra.bits_to_indices","text":"bits_to_indices(bits)\n\nReturn the positions of the ones in the unsigned integer bits.\n\nUsed to convert between representations of a unit basis blade. Inverse of indices_to_bits.\n\nExamples\n\njulia> GeometricAlgebra.bits_to_indices(0b1001101)\n4-element Vector{Int64}:\n 1\n 3\n 4\n 7\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentbits-Tuple{Any, Integer}","page":"Reference","title":"GeometricAlgebra.componentbits","text":"componentbits(n, k)\ncomponentbits(::Val{N}, ::Val{K})\n\nVector of bits corresponding to components of an n-dimensional Multivector of grade(s) k.\n\nBits are ordered first by grade (count_ones), then lexicographically (in ascending numerical order).\n\nPassing Val arguments calls a faster, memoized method.\n\nExamples\n\njulia> componentbits(4, 2) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\njulia> componentbits(3, 0:3) .|> UInt8 .|> bitstring\n8-element Vector{String}:\n \"00000000\"\n \"00000001\"\n \"00000010\"\n \"00000100\"\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00000111\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.factor_from_squares-Tuple{Any, Unsigned}","page":"Reference","title":"GeometricAlgebra.factor_from_squares","text":"factor_from_squares(sig, bits::Unsigned)\n\nCompute the overall factor arising from the geometric product between repeated basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.geometric_prod_factor-Tuple{Any, Unsigned, Unsigned}","page":"Reference","title":"GeometricAlgebra.geometric_prod_factor","text":"geometric_prod_factor(sig, a::Unsigned, b::Unsigned)\n\nThe scalar factor resulting from the geometric product between unit blades.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.indices_to_bits","page":"Reference","title":"GeometricAlgebra.indices_to_bits","text":"indices_to_bits(indices, T=UInt)\n\nCreate unsigned integer with bits at the positions given in the vector indices.\n\nUsed to convert between representations of a unit basis blade. Inverse of bits_to_indices.\n\nwarning: Warning\nOnly correct if maximum(indices) does not exceed number of bits in T.\n\nExamples\n\njulia> GeometricAlgebra.indices_to_bits([1, 2, 5], UInt8) |> bitstring\n\"00010011\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.next_bit_permutation-Tuple{Unsigned}","page":"Reference","title":"GeometricAlgebra.next_bit_permutation","text":"Return the smallest uint larger than the one given which has the same number of binary ones. Algorithm is Gosper‚Äôs hack.\n\nExamples\n\njulia> GeometricAlgebra.next_bit_permutation(0b1011) |> bitstring\n\"00001101\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.reversion_sign-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.reversion_sign","text":"reversion_sign(k) = mod(k, 4) <= 1 ? +1 : -1\n\nSign from reversing a k-vector, equal to (-1)^k(k - 1)2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.sign_from_swaps-Tuple{Unsigned, Unsigned}","page":"Reference","title":"GeometricAlgebra.sign_from_swaps","text":"sign_from_swaps(a::Unsigned, b::Unsigned)\n\nCompute sign flips of blade product due to transposing basis vectors into sorted order. (The full sign of the product will also depend on the basis norms.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{Multivector, Any}","page":"Reference","title":"Base.getindex","text":"a[k]\ngetindex(a::Multivector, k)\n\nGet the grade(s) k part of a multivector a if k ‚äÜ grade(a). The components of the resulting Multivector are a view into the components of a, so modifying a[k].comps changes a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentindices-Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:Multivector, Integer}","page":"Reference","title":"GeometricAlgebra.componentindices","text":"componentindices(a, k)\n\nIndices of the components of grade(s) k in multivector a. Throws an error if k ‚àâ grade(a).\n\nThe grade k may be an integer (returning a range) or a collection of grades (returning a vector of indices).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.grade-Tuple{AbstractMultivector, Any}","page":"Reference","title":"GeometricAlgebra.grade","text":"grade(::AbstractMultivector{Sig}, k) -> Multivector{Sig,k}\n\nConstruct a Multivector{Sig,k} from the grade k parts of a blade or multivector. Multiple grades may be specified with a range or tuple.\n\nThe operators + and - may be used as shortcuts for the even and odd parts, respectively.\n\nIf the return type must be inferable, use grade(a, Val(k)).\n\nExamples\n\njulia> grade(BasisBlade{3}(42, 0b101), 2)\n3-component Multivector{3, 2, MVector{3, Int64}}:\n  0 v12\n 42 v13\n  0 v23\n\njulia> a = Multivector{3, 0:3}(1:8);\n\njulia> grade(a, 1)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 2 v1\n 3 v2\n 4 v3\n\njulia> grade(a, 0:3:3)\n2-component Multivector{3, 0:3:3, MVector{2, Int64}}:\n 1\n 8 v123\n\njulia> grade(a, +) # only even grades\n4-component Multivector{3, 0:2:2, MVector{4, Int64}}:\n 1\n 5 v12 + 6 v13 + 7 v23\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.promote_grades-Tuple{Integer, Integer}","page":"Reference","title":"GeometricAlgebra.promote_grades","text":"promote_grades(dim, k)\n\nCanonicalize the grade type parameter k.\n\nReturns a subset of 0:dim, while attempting to normalize equivalent representations, such as 0:1:3 => 0:3 or (3, 0) => (0, 3).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.promote_grades-Tuple{Integer, OrdinalRange, Integer}","page":"Reference","title":"GeometricAlgebra.promote_grades","text":"promote_grades(dim, p, q, ...)\n\nReturn a suitable grade type parameter which contains the grades p ‚à™ q ‚à™ ....\n\nIn order to reduce the number of possible type parameters, the result may be larger than the exact union. Specifically, when combining different grades, promote_grades will try to return the narrowest grade(s) out of:\n\nan integer k ‚àà 0:dim for homogeneous elements (fewest components)\n0:dim:dim, for elements in the scalar-pseudoscalar subalgebra\n0:2:dim, for elements in the even subalgebra\n0:dim, for general inhomogeneous elements (most components)\n\nExamples\n\njulia> promote_grades(4, 0:4, 2, 7)\n0:4\n\njulia> promote_grades(4, 0, 2) # even multivectors are worth representing specifically\n0:2:4\n\njulia> promote_grades(4, 0, 3) # not worth having a specific type for grades (0, 3) in 4 dims\n0:4\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.resulting_grades-NTuple{4, Any}","page":"Reference","title":"GeometricAlgebra.resulting_grades","text":"resulting_grades(combine, dim, p, q)\n\nNon-zero grade(s) resulting from the application of combine on dim-dimensional multivectors of grade(s) p and q.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Display-methods","page":"Reference","title":"Display methods","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"show.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.show_blade-Tuple{IO, BasisBlade}","page":"Reference","title":"GeometricAlgebra.show_blade","text":"Display blade with parentheses surrounding coefficient if necessary.\n\nExample\n\njulia> GeometricAlgebra.show_blade(stdout, BasisBlade{(x=1,)}(1 + im, 0b1))\n(1 + 1im) x\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_multivector-Tuple{IO, Any}","page":"Reference","title":"GeometricAlgebra.show_multivector","text":"Display multivector components in a column or inline, optionally grouping by grade.\n\nParameters:\n\ninline::Bool: print on one line (default true)\ngroupgrades::Bool: visually group components by grade (default true).  If inline, draws parentheses around parts of each grade; if multiline, draw  each grade on its own line\nshowzeros::Bool: whether to omit zero components from display\nindent::Integer: indent amount\nparseable::Bool: use parseable style (used by repr) instead of human-readable style\n\nExamples\n\njulia> a = Multivector{2,0:2}((1:4) .^ 2);\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=false)\n 1 v\n 4 v1\n 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=true)\n1\n4 v1 + 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=true)\n(1) + (4 v1 + 9 v2) + (16 v12)\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=false)\n1 + 4 v1 + 9 v2 + 16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; parseable=true)\nMultivector{2, 0:2}([1, 4, 9, 16])\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Code-generation","page":"Reference","title":"Code generation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"generated.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.symbolic_components-Tuple{Symbol, Vararg{Integer}}","page":"Reference","title":"GeometricAlgebra.symbolic_components","text":"symbolic_components(label::Symbol, dims::Integer...)\n\nCreate an array of symbolic values of the specified shape.\n\nExample\n\njulia> GeometricAlgebra.symbolic_components(:a, 2, 3)\n2√ó3 Matrix{Any}:\n a[1, 1]  a[1, 2]  a[1, 3]\n a[2, 1]  a[2, 2]  a[2, 3]\n\njulia> prod(ans)\na[1, 1]*a[1, 2]*a[1, 3]*a[2, 1]*a[2, 2]*a[2, 3]\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.symbolic_multivector_eval-Tuple{Type{Expr}, Type, Function, Vararg{Any}}","page":"Reference","title":"GeometricAlgebra.symbolic_multivector_eval","text":"symbolic_multivector_eval(compstype, f, x::AbstractMultivector...)\n\nEvaluate f(x...) using symbolically generated code, returning a Multivector with components array of type compstype.\n\nThis is a generated function which first evaluates f on symbolic versions of the multivector arguments x and then converts the symbolic result into unrolled code.\n\nCalling symbolic_multivector_eval(Expr, compstype, f, x...) with Expr as the first argument returns the expression to be compiled.\n\nSee also @symbolic_optim.\n\nExample\n\njulia> A, B = Multivector{2,1}([1, 2]), Multivector{2,1}([3, 4]);\n\njulia> symbolic_multivector_eval(Expr, MVector, geometric_prod, A, B)\nquote # prettified for readability\n    let a = Multivector(args[1]).comps, b = Multivector(args[2]).comps\n        comps = SymbolicUtils.Code.create_array(\n            MVector, Int64, Val(1), Val((2,)),\n            a[1]*b[1] + a[2]*b[2],\n            a[1]*b[2] - a[2]*b[1],\n        )\n        Multivector{2, 0:2:2}(comps)\n    end\nend\n\njulia> @btime symbolic_multivector_eval(MVector, geometric_prod, A, B);\n  86.928 ns (3 allocations: 192 bytes)\n\njulia> @btime geometric_prod(Val(:nosym), A, B); # opt-out of symbolic optim\n  4.879 Œºs (30 allocations: 1.22 KiB)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.use_symbolic_optim-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.use_symbolic_optim","text":"use_symbolic_optim(sig) -> Bool\n\nWhether to use symbolic optimization in algebras of metric signature sig.\n\nBy default, this is enabled if dimension(sig) ‚â§ 8 (in many dimensions, algebraic expressions may become too unwieldy).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.@symbolic_optim-Tuple{Expr}","page":"Reference","title":"GeometricAlgebra.@symbolic_optim","text":"@symbolic_optim <method definition>\n\nConvert a single method definition f(args...) into two methods:\n\nThe original method f(Val(:nosym), args...), called with Val(:nosym) as the first argument. Use this method to opt-out of symbolic optimization.\nAn optimized method f(args...) which uses symbolic_multivector_eval. Code for this method is generated by calling f(Val(:nosym), args...) with symbolic versions of the Multivector arguments.\n\nThis is to reduce boilerplate when writing symbolically optimized versions of each method. It only makes sense for methods with at least one AbstractMultivector argument for which the exact return type is inferable.\n\nExample\n\n# This macro call...\n@symbolic_optim foo(a, b) = (a + b)^2\n# ...is equivalent to the following two method definitions:\n\nfoo(::Val{:nosym}, a, b) = (a + b) ^ 2\n\nfunction foo(a, b)\n    if use_symbolic_optim(foo, a, b)\n        symbolic_optim(foo, Val(:nosym), a, b)\n    else\n        foo(Val(:nosym), a, b)\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"using GeometricAlgebra","category":"page"},{"location":"theory/automorphisms/#Fundamental-Automorphisms","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Generally, operations like complex conjugation overlineAB = barAbarB or matrix transposition (AB)^ = B^A^ are useful because they preserve or reverse multiplication. (These are called automorphisms and antiautomorphisms respectively.)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Geometric algebras possess some important automorphisms: reversion tildeA, grade involution A^star and the combination of both, Clifford conjugation. These are useful unary operations which cannot be expressed in terms of simple geometric multiplication.","category":"page"},{"location":"theory/automorphisms/#Reversion","page":"Fundamental Automorphisms","title":"Reversion","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"~A or reversion(a)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Reversion tildeA is defined on multivectors A and B by the property","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"tilde(AB) = tildeBtildeA","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"and by tildeùíñ = ùíñ for vectors. Computing the reversion looks like reversing the order of the geometric product:","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"@basis 3\n~(v1*v2 + 2v1*v2*v3) == v2*v1 + 2v3*v2*v1","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Swapping orthogonal basis vectors ùêØ_iùêØ_j  ùêØ_jùêØ_i = -ùêØ_iùêØ_j introduces an overall factor of -1, and it takes binomk2 = frack(k - 1)2 swaps to reverse k many basis vectors. Thus, the reversion of a homogeneous k-vector A_k is given by","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"tildeA_k = (-1)^k(k - 1)2 A_k","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"For inhomogeneous multivectors, reversion affects each grade separately, so the result is not always simply a change in overall sign.","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Grade Reversion sign\nk (-1)^k(k - 1)2\n0 +1\n1 +1\n2 -1\n3 -1\n4 +1\n5 +1\n6 -1\n7 -1\n ","category":"page"},{"location":"theory/automorphisms/#involution","page":"Fundamental Automorphisms","title":"Grade involution","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"involution(A)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"Grade involution, sometimes denoted A^star, is the operation of reflecting space through the origin, so that vectors are sent to their negative, ùíñ  -ùíñ. Involution is required to satisfy","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"mathsfinvolution(AB) = mathsfinvolution(A)mathsfinvolution(B)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"which means a k-blade of the form B = ùêØ_1  cdots  ùêØ_k gets sent to (-ùêØ_1)  cdots  (-ùêØ_k) = (-1)^k B. By linearity, for any k-vector A we have","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"mathsfinvolution(A_k) = (-1)^k A_k","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"but for inhomogeneous multivectors, involution is not always an overall change in sign.","category":"page"},{"location":"theory/automorphisms/#Clifford-conjugation","page":"Fundamental Automorphisms","title":"Clifford conjugation","text":"","category":"section"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"clifford_conj(A)","category":"page"},{"location":"theory/automorphisms/","page":"Fundamental Automorphisms","title":"Fundamental Automorphisms","text":"The composition of reversion and involution tildeA^star is also called the Clifford conjugate.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"using GeometricAlgebra","category":"page"},{"location":"#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"GeometricAlgebra.jl implements a flexible, performant type for multivectors in geometric (or Clifford) algebra.","category":"page"},{"location":"#Installation","page":"User Guide","title":"Installation","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"This package is not yet registered, but can be installed directly from source.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"julia> using Pkg\n\njulia> Pkg.add(url=\"https://github.com/Jollywatt/GeometricAlgebra.jl\", rev=\"v0.2.1\")\n\njulia> using GeometricAlgebra","category":"page"},{"location":"#Quick-start","page":"User Guide","title":"Quick start","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"To construct a geometric multivector from a vector of components, provide the metric signature and grade as type parameters.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"For example, a 3D Euclidean vector of grade one is a Multivector{3,1}.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"u = Multivector{3,1}([1, -1, 0])","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"The Multivector type is essentially a wrapper which signifies the parent algebra and grade(s) of the underlying components vector (accessed with u.comps).","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Many multivector operations are implemented, including:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"+, -, * (geometric_prod), inv, /\ngrade for grade projection, scalar\n‚àß (wedge), ‚à® (antiwedge), ‚ãÖ (inner), ‚äô (scalar_prod), ‚®º (lcontract), ‚®Ω (rcontract)\n~ (reversion), involution, clifford_conj\nldual, rdual, hodgedual\nexp, log, trigonometric functions","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Non-euclidean metric signatures can be specified, such as Cl(3,0,1) for projective geometric algebra (PGA), or a named tuple such as (t=-1, x=+1) for custom basis vector names (see Custom basis display styles for more control).","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"For example, here is a bivector in the spacetime algebra (STA) using the (-+++) metric.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"B = Multivector{Cl(\"-+++\"),2}(1:6) # Lorentzian bivector\nexp(B)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Notice that the grades parameter of this bivector exponential is 0:2:4, for an even multivector having 8 components (instead of 16 components of a general 4D multivector).","category":"page"},{"location":"#Working-with-an-orthonormal-basis","page":"User Guide","title":"Working with an orthonormal basis","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"You can obtain an orthonormal basis for a metric signature with basis.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"v = basis(3)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"BasisBlades represent individual components of a Multivector. The macro @basis introduces basis blades into the current namespace for interactive use.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"@basis \"+---\"\n1 + 10v23 + 1000/I\n@basis (t = +1, x = -1) allperms=true\n6tx == -6xt","category":"page"},{"location":"#Custom-basis-display-styles","page":"User Guide","title":"Custom basis display styles","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"You can customise both the notation and canonical ordering with which basis blades are displayed to agree with conventions. This can be done by defining a BasisDisplayStyle(dim; kwargs...) and setting a key of GeometricAlgebra.BASIS_DISPLAY_STYLES.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Some example styles for v12 + 2v13 are:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Notation Display style Keyword arguments\nùêû_12 + 2ùêû_13 ùêû12 + 2ùêû13 prefix=\"ùêû\"\nŒ≥^0Œ≥^1 + 2Œ≥^0Œ≥^2 Œ≥‚Å∞Œ≥¬π + 2Œ≥‚Å∞Œ≥¬≤ prefix=\"Œ≥\", sep=\"\", indices=0:3\nmathrmdx  mathrmdy - 2 mathrmdz  mathrmdx dx ‚àß dy - 2 dz ‚àß dx prefix=\"d\", sep=\" ‚àß \", indices=\"xyz\"","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"The last style additionally uses a custom basis blade ordering.","category":"page"},{"location":"#Custom-basis-blade-orderings","page":"User Guide","title":"Custom basis blade orderings","text":"","category":"section"},{"location":"","page":"User Guide","title":"User Guide","text":"By default, multivectors are displayed with their components the same sign and in the same order as they are stored. Internally, the basis vectors in a blade are encoded in binary and assumed to be in order of increasing index.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"BasisBlade{4}(42, 0b1101)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Multivector components are stored in order of grade, then by binary value. For example, the components of a full 3D multivector correspond to the basis blades:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"GeometricAlgebra.componentbits(Multivector{3,0:3}) .|> UInt8 .|> bitstring","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"However, it can sometimes be convenient to adopt different conventions. For example, in 3D, it is common to see ‚Äúcyclical‚Äù basis bivectors, (ùêØ_23 ùêØ_31 ùêØ_12), as these are the respective duals of (ùêØ_1 ùêØ_2 ùêØ_3). This style can be achieved as follows:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"style = BasisDisplayStyle(\n\t3, # dimension of algebra\n\tDict(2 => [[2,3], [3,1], [1,2]]), # indices and order of basis bivectors\n\tprefix=\"ùêû\"\n)\nGeometricAlgebra.BASIS_DISPLAY_STYLES[3] = style;","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"The second argument of BasisDisplayStyle defines the complete list of basis blade indices for each grade.","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"With this style, it is easier to ‚Äúread off‚Äù the duals of a 3D (bi)vector:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"u = Multivector{3,1}(rand(1:100, 3))\nldual(u)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"Notice how the vector and dual vector components align nicely. To recover the default style:","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"delete!(GeometricAlgebra.BASIS_DISPLAY_STYLES, 3)\nldual(u)","category":"page"},{"location":"","page":"User Guide","title":"User Guide","text":"note: Note\nBasisDisplayStyle does not affect how components are stored internally. Bear this in mind when accessing the components field of a Multivector when using a style with custom ordering.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/rotors/#Rotors","page":"Rotors","title":"Rotors","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Rotors are multivectors which describe proper rotations. The rotors formalism provides an extremely uniform, elegant and efficient description of rotations. For motivation, it is helpful to consider rotations in simpler algebras.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"In the complex plane, a complex number z  ‚ÑÇ is rotated about the origin with the mapping z  e^iŒ∏z. Similarly, a quaternion q  ‚Ñç is rotated about an axis n with q  e^n2qe^-n2. Indeed, the double-sided transformation law","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"A  e^B2Ae^-B2","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"is general to both ‚ÑÇ and ‚Ñç, and in fact applies to geometric algebras of any dimension. Specifically, the rotor R = e^B2 describes a rotation in the plane spanned by the bivector B by an angle described by its magnitude.","category":"page"},{"location":"theory/rotors/#Reflections-and-orthogonal-transformations","page":"Rotors","title":"Reflections and orthogonal transformations","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"To see how the double-sided transformation law arises, note that any orthogonal transformation in n dimensions is the same as at most n reflections (the Cartan‚ÄìDieudonn√© theorem). A reflection is described in a geometric algebra by conjugation with an invertible vector. For instance, the linear map","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tA  -ùíóAùíó^-1","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"reflects the multivector A along the vector ùíó (or across the hyperplane with normal ùíó).[1]","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"[1]: To see this, consider the case where A is a vector parallel or orthogonal to ùíó.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"note: Note\nScaling each ùíó by a non-zero scalar Œª does not affect the reflection. Therefore, a direct correspondence exists between reflections and normalised vectors ùíó^2 = 1, modulo overall sign (since ùíó and -ùíó describe the same reflection).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"By composing reflections as above, we can obtain any orthogonal transformation, acting as","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tA  RAR^-1","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"for some R = ùíó_1ùíó_2ùíó_k. The overall sign is positive for an even number of reflections (giving a proper rotation), and negative for an odd number.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Without loss of generality, we may use normalised vectors, so that the inverse is","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tR^-1 = ùíó_k^-1cdots ùíó_2^-1ùíó_1^-1 = tildeR","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"since ùíó^-1 = ùíó. Hence, an orthogonal transformation is described by","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tA  RAtildeR","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"where R is satisfies R^-1 = tildeR.","category":"page"},{"location":"theory/rotors/#Rotor-groups","page":"Rotors","title":"Rotor groups","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"All such multivectors satisfying R^-1 = tildeR taken together form a group under the geometric product. This is called the pin group:","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tmathsfPin(p q)  big R  Cl(p q) mid RtildeR = 1 big","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"There are two ‚Äúpinors‚Äù for every orthogonal transformation, namely +R and -R. Thus, the pin group forms a double cover of the orthogonal group mathsfO(pq).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Furthermore, the even-grade elements of mathsfPin(pq) form a subgroup, called the spin group:","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tmathsfSpin(p q)  big R  Cl_+(p q) mid RtildeR = 1 big","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"The spin group, in turn, forms a double cover of the special orthogonal group mathsfSO(p q).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Finally, the additional requirement that RtildeR = 1 defines the restricted spinor group, or the rotor group:","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\tmathsfSpin^+(p q)  big R  Cl_+(p q) mid RtildeR = 1 big","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"The rotor group is a double cover of the restricted special orthogonal group mathsfSO^+(p q), which is the identity-connected part of mathsfSO(p q).","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"The takeaway is that any orthogonal transformation, including reflections, rotations, and combinations of both, can be described within geometric algebra with rotors, no matter the kind of multivector being transformed, and independent of the dimension or signature of the algebra. In particular, proper rotations are described by rotors, or even multivectors satisfying RtildeR = 1.","category":"page"},{"location":"theory/rotors/#The-bivector-subalgebra","page":"Rotors","title":"The bivector subalgebra","text":"","category":"section"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"Bivectors play a special role as the generators of rotors. Because the even subalgebra is closed under the geometric product, the exponential","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"\te^B = 1 + B + B^22 +   mathsfSpin^+","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"of a bivector B is always an even multivector, and the reverse tilde(e^B) = e^-B is the inverse. Therefore, e^B  mathsfSpin^+ is a rotor; and indeed, any rotor R  mathsfSpin^+ is of the form","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"R = e^B","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"for some bivector B.","category":"page"},{"location":"theory/rotors/","page":"Rotors","title":"Rotors","text":"note: Bivector Lie algebra\nFormally, bivectors form a Lie algebra under the commutator product A  B  frac12(AB - BA). Indeed, this demonstrates a Lie group‚ÄìLie algebra correspondence between the rotor group mathsfSpin^+ and bivectors equipped with .","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"theory/dualities/#Dualities","page":"Dualities","title":"Dualities","text":"","category":"section"},{"location":"theory/dualities/#Pseudoscalar-duality","page":"Dualities","title":"Pseudoscalar duality","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The highest-grade elements, pseudoscalars, play a special role in geometric algebra. The unit pseudoscalar","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"I  ùêØ_1ùêØ_2ùêØ_n","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"is interpreted as an oriented unit volume.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"warning: Warning\nThe unit pseudoscalar I is not to be confused with the identity matrix or unit imaginary i. Indeed, I does not always commute, and I^2 = 1 depending on the algebra.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"Multiplying by I sends k-vectors to (n - k)-vectors. In odd dimensions, left- and right-multiplication by the unit pseudoscalar is identical:","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"AI = IA\nquadtext(in odd dimensions)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"for any multivector A. However, in even dimensions, odd-grade elements anticommute with I.","category":"page"},{"location":"theory/dualities/#Hodge-duality","page":"Dualities","title":"Hodge duality","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"hodgedual(A)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The Hodge dual is a combination of reversion and multiplication by I:","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"mathsfhodgedual(A) = tildeAI","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"This comes from the Hodge star operator from exterior algebra, which is a metrical duality operation implicitly defined on two k-vectors A and B by","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"A  mathsfhodgedual(B) = A B I","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"where A B is the induced inner product on k-vectors. In the language of geometric algebra, this is","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"A B = A odot tildeB = A lcontr tildeB","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"and by using the identity (A lcontr tildeB)I = A  (tildeBI) we have A  mathsfhodgedual(B) = A  (tildeBI) which shows the equivalence with the explicit definition above.","category":"page"},{"location":"theory/dualities/#Comparison-with-pseudoscalar-duality","page":"Dualities","title":"Comparison with pseudoscalar-duality","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"For homogeneous multivectors, Hodge duality and pseudoscalar-duality differ only in overall sign.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The square of the Hodge dual is mathsfhodgedual^2(A) = (-1)^s(-1)^k(n - k) A and hence the inverse is","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"mathsfhodgedual^-1(A) = (-1)^s(-1)^k(n - k) mathsfhodgedual(A) ","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"where s is the trace of the metric.[1] Note that this depends on the grade k of A.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"[1]: Lemma 6, Joseph Wilson (2022)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"By contrast, I^2 = 1 and hence I^-1 = I does not depend on the multivector it acts on. (This generally makes pseudoscalar-duality easier to work with algebraically!)","category":"page"},{"location":"theory/dualities/#Left-and-right-complements","page":"Dualities","title":"Left and right complements","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"ldual, rdual","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The left and right complements are dual operations which do not involve multiplication by the pseudoscalar I, and so are metric independent. Some authors denote the left and right complements by underlineA and overlineA, respectively.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"For a unit basis blade a, the complements are uniquely defined by","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"textsfldual(a)a = I = atextsfrdual(a)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"and are extended linearly to act on general multivectors. They are inverses of each other,","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"textsfldual(textsfrdual(a)) = a = textsfrdual(textsfldual(a))","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"and in odd-dimensional algebras, are identical.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"The metric-independence of the left and right duals mean they are useful even in degenerate algebras, since a non-zero multivector always has a non-zero dual even when its Hodge dual is zero.","category":"page"},{"location":"theory/dualities/#Dualized-products","page":"Dualities","title":"Dualized products","text":"","category":"section"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"It is common to work both with multivectors and their duals in the same context, and hence convenient to define ‚Äúdualized‚Äù versions of certain products. For example, the regressive product  is the dualized wedge product , defined by","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"D(a  b) = D(a)  D(b)","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"where D is a dual operation such as textsfldual or textsfrdual (each results in an equivalent definition).","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"In the context of point-based projective geometric algebra, the -product of two objects forms the join (e.g., the line joining two points) while the -product of two objects forms the meet (e.g., the point where two lines meet) and vice versa in plane-based PGA.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"Similar products may be defined by dualizing the inner product and contractions[2] but these are less common.","category":"page"},{"location":"theory/dualities/","page":"Dualities","title":"Dualities","text":"[2]: See the ‚Äúanti-products‚Äù defined in Lengyel‚Äôs wiki.","category":"page"}]
}
