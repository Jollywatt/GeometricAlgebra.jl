var documenterSearchIndex = {"docs":
[{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"design/#Design-and-Internals","page":"Design and Internals","title":"Design and Internals","text":"","category":"section"},{"location":"design/#Multivector-Types","page":"Design and Internals","title":"Multivector Types","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"There are two concrete types for representing elements in a geometric algebra:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}    Multivector{Sig,K,S}","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"BasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Type parameters:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Sig: The metric signature which defines the geometric algebra. This can be any  all-bits value which satisfies the metric signature interface.\nK: The grade(s) of a multivector. For BasisBlades, this is an integer, but for Multivectors, it may be a collection (e.g., 0:3 for a general 3D multivector).\nT: The numerical type of the coefficient of a BasisBlade.\nS: The storage type of the components of a Multivector, usually an AbstractVector subtype.","category":"page"},{"location":"design/#Metric-Signatures","page":"Design and Internals","title":"Metric Signatures","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter Sig defines the dimension of the geometric algebra and the norms of its standard orthonormal basis vectors. Additionally, it allows various default behaviours to be customised through method definitions which dispatch on Sig, as detailed in the metric signature interface.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, the following metric signature types are implemented:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Int, defining a Euclidean metric of that dimension,\nTuple, defining the norms of each basis vector,\nNamedTuple, defining basis vector labels as well as norms,\nCl, a type resembling the notation Cl(p q r) common in literature.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> @basis 2\n[ Info: Defined basis blades v, v1, v2, v12\n\njulia> basis((t=-1, x=1, y=1, z=1)) |> prod\nBasisBlade{(t = -1, x = 1, y = 1, z = 1), 4, Int64}:\n 1 txyz\n","category":"page"},{"location":"design/#sig-interface","page":"Design and Internals","title":"The metric signature interface","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"The metric signature type parameter may be any isbits value satisying the following interface. As well as defining the geometric algebra, the signature is used to specify basis blade labels, the default array type for multivector components, and other metadata.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Required methods Description\ndimension(sig) The dimension of the underlying vector space, or number of basis vectors.\nbasis_vector_norm(sig, i) The norm of the ith basis vector.","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Optional methods Description\nshow_signature(io, sig) Show the metric signature in a compact human-readable form.\nshow_basis_blade(io, sig, indices) Print a basis blade with the given indices (e.g., v12 or 𝒆₁∧𝒆₂).\ncomponentstype(sig, N, T) Preferred array type for CompositeMultivector components. (Default is Vector{T} in low dimensions and SparseVector{T} otherwise.)\nsymbolic_optim(sig) Whether to use symbolic code generation to optimise multivector products. (Default is true for low dimensions.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Below is an example of how one might define a geometric algebra with specific behaviours:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"struct DiracGamma end\n\n# define the algebra\nGeometricAlgebra.dimension(::DiracGamma) = 4\nGeometricAlgebra.basis_vector_norm(::DiracGamma, i) = i > 1 ? -1 : +1\n\n# set the preferred component storage type (optional)\nusing StaticArrays\nGeometricAlgebra.componentstype(::DiracGamma, N, T) = MVector{N,T}\n\n# custom labels (optional)\nfunction GeometricAlgebra.show_basis_blade(io, ::DiracGamma, indices)\n\tprint(io, join(\"γ\".*GeometricAlgebra.superscript.(indices .- 1)))\nend\n\nbasis(DiracGamma())\n# output\n4-element Vector{BasisBlade{DiracGamma(), 1, Int64}}:\n γ⁰\n γ¹\n γ²\n γ³","category":"page"},{"location":"design/#Symbolic-Algebra-and-Code-Generation","page":"Design and Internals","title":"Symbolic Algebra and Code Generation","text":"","category":"section"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"Thanks to the wonderful SymbolicUtils package, the same code originally written for numerical multivectors readily works with symbolic components. For example, we can compute the product of two vectors symbolically as follows:","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"julia> GeometricAlgebra.symbolic_components.([:x, :y], 3)\n2-element Vector{Vector{Any}}:\n [x[1], x[2], x[3]]\n [y[1], y[2], y[3]]\n\njulia> Multivector{3,1}.(ans)\n2-element Vector{Multivector{3, 1, Vector{Any}}}:\n x[1]v1 + x[2]v2 + x[3]v3\n y[1]v1 + y[2]v2 + y[3]v3\n\njulia> prod(ans)\n4-component Multivector{3, 0:2:2, Vector{Any}}:\n x[1]*y[1] + x[2]*y[2] + x[3]*y[3]\n x[1]*y[2] - x[2]*y[1] v12 + x[1]*y[3] - x[3]*y[1] v13 + x[2]*y[3] - x[3]*y[2] v23\n","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"This makes it easy to optimize multivector operations by first performing the general calculation symbolically, then converting the resulting expression into unrolled code.  (See symbolic_optim() for details.)","category":"page"},{"location":"design/","page":"Design and Internals","title":"Design and Internals","text":"By default, symbolic code generation is used for most products in up to eight dimensions (above which general algebraic expressions become unwieldy). This can be changed on a per-algebra basis by defining methods for use_symbolic_optim().","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Multivector-Types","page":"Reference","title":"Multivector Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"types.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.AbstractMultivector","page":"Reference","title":"GeometricAlgebra.AbstractMultivector","text":"AbstractMultivector{Sig}\n\nSupertype of all elements in the geometric algebra defined by the metric signature Sig.\n\nSubtypes\n\n         AbstractMultivector{Sig}\n            /               \\                             \nBasisBlade{Sig,K,T}   Multivector{Sig,K,S}                \n\nBasisBlade: a scalar multiple of a wedge product of orthogonal basis vectors.\nMultivector: a homogeneous or inhomogeneous multivector; a sum of basis blades.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.BasisBlade","page":"Reference","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig,K,T}\n\nA basis blade of grade K and scalar coefficient of type T.\n\nBasis blades are scalar multiples of wedge products of orthogonal basis vectors.\n\nnote: Note\nNot every k-blade (i.e., wedge product of k linearly independent vectors) is representable as a BasisBlade. However, every k-blade is a Multivector of grade k.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK::Int: Grade of the blade, equal to count_ones(bits), retrieved with grade().\nT: Numerical type of the scalar coefficient, retrieved with eltype().\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.BasisBlade-Union{Tuple{Pair}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.BasisBlade","text":"BasisBlade{Sig}(bits, coeff)\nBasisBlade{Sig}(bits => coeff)\n\nBasis blade with indices encoded by bits and scalar coefficient coeff.\n\nIndices are encoded in binary (e.g., v₁v₃v₄ has bits 0b1101).\n\nExamples\n\njulia> BasisBlade{3}(0b110 => 42) # a grade 2 blade in 3 dimensions\nBasisBlade{3, 2, Int64}:\n 42 v23\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.Multivector","page":"Reference","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K,S} <: AbstractMultivector{Sig}\n\nA general multivector with parts of grade ∈ K.\n\nFor homogeneous k-vectors, the grade parameter K is an integer. Inhomogeneous multivectors may be specified with a range or tuple of grades.\n\nParameters\n\nSig: Metric signature defining the geometric algebra, retrieved with signature().\nK: Grade(s) present in the multivector. Can be an integer or a collection of integers (a range or tuple).\nS: Storage type of the multivector components, usually a subtype of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.Multivector-Union{Tuple{S}, Tuple{K}, Tuple{Sig}} where {Sig, K, S}","page":"Reference","title":"GeometricAlgebra.Multivector","text":"Multivector{Sig,K}(comps)\n\nMultivector with grade(s) K and component vector comps.\n\nComponents are ordered first by grade, then lexicographically by bits (see componentbits).\n\nExamples\n\njulia> Multivector{3,0:3}(1:2^3)\n8-component Multivector{3, 0:3, UnitRange{Int64}}:\n 1\n 2 v1 + 3 v2 + 4 v3\n 5 v12 + 6 v13 + 7 v23\n 8 v123\n\njulia> grade(ans, 1)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 2 v1\n 3 v2\n 4 v3\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.eltype-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:(BasisBlade{Sig, K, T} where {Sig, K})}, Tuple{T}} where T","page":"Reference","title":"Base.eltype","text":"eltype(::AbstractMultivector)\n\nThe numerical type of the components of a multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentindex-Tuple{Any, BasisBlade}","page":"Reference","title":"GeometricAlgebra.componentindex","text":"componentindex(a::Multivector, b)\n\nIndex of components vector of a corresponding to the BasisBlade or bits b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.dimension-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.dimension","text":"dimension(sig)\ndimension(::AbstractMultivector)\n\nThe dimension of the underlying vector space of the geometric algebra. See ncomponents for the dimension of the algebra (i.e., the number of independent components of a general multivector).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ncomponents-Tuple{Multivector}","page":"Reference","title":"GeometricAlgebra.ncomponents","text":"ncomponents(::CompositeMultivector)\n\nNumber of independent components of a multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.resulting_grades-NTuple{4, Any}","page":"Reference","title":"GeometricAlgebra.resulting_grades","text":"resulting_grades(combine, dim, p, q)\n\nNon-zero grade(s) resulting from the application of combine on dim-dimensional multivectors of grade(s) p and q.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.resulting_multivector_type-Union{Tuple{Sig}, Tuple{Any, Vararg{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}}} where Sig","page":"Reference","title":"GeometricAlgebra.resulting_multivector_type","text":"resulting_multivector_type(f, a, b, ...)\n\nMultivector type with grade(s) and storage type appropriate for representing f(a, b).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.signature-Union{Tuple{Union{Type{var\"#s4\"}, var\"#s4\"} where var\"#s4\"<:AbstractMultivector{Sig}}, Tuple{Sig}} where Sig","page":"Reference","title":"GeometricAlgebra.signature","text":"signature(::AbstractMultivector{Sig}) = Sig\n\nThe metric signature type parameter of the multivector instance (or type).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.unify_grades-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.unify_grades","text":"unify_grades(dim, p, q)\n\nReturn grade(s) containing both p and q.\n\nIn order to reduce the number of possible Multivector grade parameters (which will be compiled separately) the result may be larger than the union p ∪ q.\n\nExamples\n\njulia> unify_grades(4, 0:4, 2)\n0:4\n\njulia> unify_grades(4, 0, 2) # even multivectors are worth representing specifically\n0:2:4\n\njulia> unify_grades(4, (0, 4), 3) # not worth having a special type for grades (0, 3, 4)\n0:4\n\n\n\n\n\n","category":"method"},{"location":"reference/#Algebraic-Operations","page":"Reference","title":"Algebraic Operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"algebra.jl\", \"special.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#Base.:~-Tuple{AbstractMultivector}","page":"Reference","title":"Base.:~","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector, ~k == reversion_sign(k) == (-1)^(k*(k - 1)/2).\n\nmod(k, 4) reversion_sign(k)\n0 +1\n1 +1\n2 -1\n3 -1\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:'ᶜ-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.:'ᶜ","text":"a'ᶜ\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:∧-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:∧","text":"a ∧ b\nwedge(a, b)\n\nWedge product of multivectors, a.k.a. the outer, exterior or alternating product.\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a ∧ b is the grade p + q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:⊙-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:⊙","text":"a ⊙ b\nscalar_prod(a, b) -> Number\n\nScalar part of the multivector product a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:⋅-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:⋅","text":"a ⋅ b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(abs∘-, a, b). If a and b are of grades p and q respectively, then a ⋅ b is the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see [D02] for discussion).\n\n[D02]: Leo Dorst, \"The Inner Products of Geometric Algebra\", 2002. doi:10.1007/978-1-4612-0089-5_2\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:⨼-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:⨼","text":"a ⨼ b\nlcontract(a, b)\n\nLeft contraction of multivectors. See also rcontract.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a ⨼ b is the grade q - p part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.:⨽-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.:⨽","text":"a ⨽ b\nrcontract(a, b)\n\nLeft contraction of multivectors. See also lcontract.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a ⨽ b is the grade p - q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.clifford_conj-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.clifford_conj","text":"a'ᶜ\nclifford_conj(a)\n\nClifford conjugate of a multivector.\n\nEquivalent to reversion(involution(a)).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.flipdual","page":"Reference","title":"GeometricAlgebra.flipdual","text":"flipdual(a)\n\nA dual of a multivector, for when the overall sign isn’t important.\n\nFor a unit basis blade a::BasisBlade, the flipdual satisfies a*flipdual(a) == ±I where ±I is the unit pseudoscalar or its negative.\n\nComputing the flipdual is cheap, and is its own inverse: for a BasisBlade, its bits are flipped, and for a CompositeMultivector, the components vector is simply reversed.\n\nThe flipdual is metric independent, but depends on a choice of basis. It differs from the Hodge and Poincaré duals by a per-grade scalar factor. This makes it useful in projective geometry, where scalar factors are largely arbitrary.\n\nSee also hodgedual and poincaredual.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.geometric_prod-Tuple{Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.geometric_prod","text":"a * b\ngeometric_prod(a, b)\n\nGeometric product of multivectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.graded_multiply-Tuple{Any, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.graded_multiply","text":"graded_multiply(f, a::AbstractMultivector)\n\nMultiply the grade k part of a by f(k).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.graded_prod-Tuple{Any, Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.graded_prod","text":"graded_prod(grade_selector::Function, a, b)\n\nA \"graded\" product of multivectors, generalising the wedge , inner  and contraction products. For example, the wedge product is defined as:\n\nwedge(a, b) = graded_prod(+, a, b)\n\nIf grade(a) == p and grade(b) == q, then graded_prod(f, a, b) is the grade f(p, q) part of a*b. The definition extends linearly to general multivectors A and B as\n\n\t(A B)  sum_pq A_p B_q_f(p q)\n\nwhere _k denotes the grade k part.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.hodgedual","page":"Reference","title":"GeometricAlgebra.hodgedual","text":"hodgedual(a) = ~a*I\n\nHodge dual of a multivector.\n\nThe Hodge dual is given by\n\na = a I\n\nwhere a is the reversion of a and I is the unit pseudoscalar. For k-vectors a and b, it is alternatively defined by\n\na  b = a b I\n\nwhere a b = a  b is the induced inner product on k-vectors.\n\nThe Hodge dual depends on the metric and orientation (choice of pseudoscalar).\n\nSee also poincaredual.\n\nExamples\n\njulia> u = Multivector{3,1}(1:3)\n3-component Multivector{3, 1, UnitRange{Int64}}:\n 1 v1\n 2 v2\n 3 v3\n\njulia> hodgedual(u)\n3-component Multivector{3, 2, Vector{Int64}}:\n  3 v12\n -2 v13\n  1 v23\n\njulia> u ∧ hodgedual(u), u ⊙ ~u\n(14v123, 14)\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.inner-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.inner","text":"a ⋅ b\ninner(a, b)\n\nInner product of multivectors.\n\nThis is a grade lowering operation, equivalent to graded_prod(abs∘-, a, b). If a and b are of grades p and q respectively, then a ⋅ b is the grade p - q part of a*b.\n\nNote that for scalars a and b, the inner product reduces to scalar multiplication, in contrast to some authors (see [D02] for discussion).\n\n[D02]: Leo Dorst, \"The Inner Products of Geometric Algebra\", 2002. doi:10.1007/978-1-4612-0089-5_2\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.involution-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.involution","text":"involution(a)\n\nInvolute of a multivector.\n\nInvolution is an automorphism defined by reflecting through the origin: for homogeneous multivectors, involution(a) == (-1)^grade(a)*a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.lcontract-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.lcontract","text":"a ⨼ b\nlcontract(a, b)\n\nLeft contraction of multivectors. See also rcontract.\n\nEquivalent to graded_prod((p, q) -> q - p, a, b). If a and b are of grades p and q respectively, then a ⨼ b is the grade q - p part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.poincaredual","page":"Reference","title":"GeometricAlgebra.poincaredual","text":"poincaredual(a)\n\nPoincaré dual of a multivector.\n\nFor a unit basis blade a::BasisBlade, the Poincaré dual satisfies a*poincaredual(a) == I where I is the unit pseudoscalar. I.e., poincaredual(a) is a “right complement” of a.\n\nThe Poincaré dual is metric independent, but depends on a choice of basis. This makes is useful in degenerate algebras: non-zero multivectors have non-zero Poincaré duals, even if their Hodge dual is zero.\n\nSee also hodgedual and flipdual.\n\nExamples\n\njulia> @basis Cl(2,0,1)\n[ Info: Defined basis blades v, v1, v2, v3, v12, v13, v23, v123\n\njulia> hodgedual(v3), v3*v123 # Hodge dual is zero because v3*v3 == 0\n(0, 0)\n\njulia> poincaredual(v3)\nBasisBlade{Cl(2,0,1), 2, Int64}:\n 1 v12\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.rcontract-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.rcontract","text":"a ⨽ b\nrcontract(a, b)\n\nLeft contraction of multivectors. See also lcontract.\n\nEquivalent to graded_prod(-, a, b). If a and b are of grades p and q respectively, then a ⨽ b is the grade p - q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.reversion-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.reversion","text":"~a\nreversion(a::AbstractMultivector)\n\nReversion of a multivector.\n\nReversion is an anti-automorphism defined by reversing the order of the geometric product: ~(a*b) == ~b * ~a. For a k-vector, ~k == reversion_sign(k) == (-1)^(k*(k - 1)/2).\n\nmod(k, 4) reversion_sign(k)\n0 +1\n1 +1\n2 -1\n3 -1\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.scalar_prod-Tuple{Union{Number, SymbolicUtils.Symbolic}, Union{Number, SymbolicUtils.Symbolic}}","page":"Reference","title":"GeometricAlgebra.scalar_prod","text":"a ⊙ b\nscalar_prod(a, b) -> Number\n\nScalar part of the multivector product a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.wedge-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.wedge","text":"a ∧ b\nwedge(a, b)\n\nWedge product of multivectors, a.k.a. the outer, exterior or alternating product.\n\nThis is a grade-raising operation, equivalent to graded_prod(+, a, b). If a and b are of grades p and q respectively, then a ∧ b is the grade p + q part of a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.matrix_repr-Tuple{BasisBlade}","page":"Reference","title":"GeometricAlgebra.matrix_repr","text":"matrix_repr(a::AbstractMultivector)\n\nMatrix representation of a multivector.\n\nThis is an injective homomorphism from the geometric algebra to a matrix subalgebra (i.e., it is linear, and preserves algebraic products).\n\nSee also vector_repr.\n\nExamples\n\njulia> @basis 2\n[ Info: Defined basis blades v, v1, v2, v12\n\njulia> matrix_repr(v1)\n4×4 Matrix{Int64}:\n 0  1  0  0\n 1  0  0  0\n 0  0  0  1\n 0  0  1  0\n\njulia> matrix_repr(v1*v2) == matrix_repr(v1)matrix_repr(v2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.vector_repr-Tuple{AbstractMultivector}","page":"Reference","title":"GeometricAlgebra.vector_repr","text":"vector_repr(a::AbstractMultivector)\n\nVector representation of a multivector. See also matrix_repr.\n\nExamples\n\njulia> @basis 2\n[ Info: Defined basis blades v, v1, v2, v12\n\njulia> vector_repr(v1*v2) == matrix_repr(v1)vector_repr(v2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#Metric-Signatures","page":"Reference","title":"Metric Signatures","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"signatures.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.Cl","page":"Reference","title":"GeometricAlgebra.Cl","text":"Cl(p, q=0, r=0)\n\nMetric signature where p, q and r is the number of basis vectors of norm +1, -1 and 0, respectively.\n\nExamples\n\njulia> basis(Cl(1,3))\n4-element Vector{BasisBlade{Cl(1,3), 1, Int64}}:\n v1\n v2\n v3\n v4\n\njulia> ans .^ 2\n4-element Vector{BasisBlade{Cl(1,3), 0, Int64}}:\n  1\n -1\n -1\n -1\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.basis","page":"Reference","title":"GeometricAlgebra.basis","text":"basis(sig, grade=1)\n\nVector of basis blades of specified grade(s) for the geometric algebra defined by the metric signature sig.\n\nSee also @basis and @basisall.\n\nExamples\n\njulia> basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n v1\n v2\n v3\n\njulia> basis(\"-+++\", 0:2:4)\n8-element Vector{BasisBlade{⟨-+++⟩, _A, Int64} where _A}:\n 1\n v12\n v13\n v23\n v14\n v24\n v34\n v1234\n\njulia> basis(Cl(1,3), 2)\n6-element Vector{BasisBlade{Cl(1,3), 2, Int64}}:\n v12\n v13\n v23\n v14\n v24\n v34\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.cayleytable-Tuple","page":"Reference","title":"GeometricAlgebra.cayleytable","text":"cayleytable(sig, op=*)\ncayleytable(objs, op=*)\n\nDisplay a multivector multiplication table.\n\nThe first argument may be a metric signature or any vector of objects which can be combined with the binary operator op.\n\nThe keyword argument title sets the contents of the top-left cell.\n\nExamples\n\njulia> cayleytable(3)\n (↓) * (→) │    1 │   v1     v2    v3 │  v12    v13   v23 │ v123\n───────────┼──────┼───────────────────┼───────────────────┼──────\n         1 │    1 │   v1     v2    v3 │  v12    v13   v23 │ v123\n───────────┼──────┼───────────────────┼───────────────────┼──────\n        v1 │   v1 │    1    v12   v13 │   v2     v3  v123 │  v23\n        v2 │   v2 │ -v12      1   v23 │  -v1  -v123    v3 │ -v13\n        v3 │   v3 │ -v13   -v23     1 │ v123    -v1   -v2 │  v12\n───────────┼──────┼───────────────────┼───────────────────┼──────\n       v12 │  v12 │  -v2     v1  v123 │   -1   -v23   v13 │  -v3\n       v13 │  v13 │  -v3  -v123    v1 │  v23     -1  -v12 │   v2\n       v23 │  v23 │ v123    -v3    v2 │ -v13    v12    -1 │  -v1\n───────────┼──────┼───────────────────┼───────────────────┼──────\n      v123 │ v123 │  v23   -v13   v12 │  -v3     v2   -v1 │   -1\n\njulia> cayleytable(basis((t=-1, x=1, y=1, z=1), 2), ∧)\n (↓) ∧ (→) │   tx     ty    xy    tz     xz    yz\n───────────┼──────────────────────────────────────\n        tx │    0      0     0     0      0  txyz\n        ty │    0      0     0     0  -txyz     0\n        xy │    0      0     0  txyz      0     0\n        tz │    0      0  txyz     0      0     0\n        xz │    0  -txyz     0     0      0     0\n        yz │ txyz      0     0     0      0     0\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentstype-Tuple{Any, Any, Any}","page":"Reference","title":"GeometricAlgebra.componentstype","text":"componentstype(sig, N, T)\n\nDefault array type used to store components of multivectors of signature sig. The resulting type should be able to store N components (in the case of a fixed-size array) of type T.\n\nThe fallback method returns Vector{T} for dimension(sig) <= 8, and SparseVector{T} otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.ncomponents-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.ncomponents","text":"ncomponents(sig)\nncomponents(sig, k)\n\nDimension of (the grade-k subspace of) the geometric algebra of metric signature sig, viewed as a vector space.\n\nIf the dimension of the underlying vector space (see dimension) in n, then the algebra is 2^n-dimensional, and its grade-k subspace binomnk-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_basis_blade-Tuple{Any, Any, Any}","page":"Reference","title":"GeometricAlgebra.show_basis_blade","text":"show_basis_blade(io, sig, indices::Vector{Int})\n\nShow the basis blade with unit vectors in indices for the geometric algebra defined by sig. Methods dispatching on sig should be added to customise basis blade labels for particular algebras.\n\nExamples\n\njulia> GeometricAlgebra.show_basis_blade(stdout, (1, 1, 1), [1, 3])\nv13\n\njulia> using GeometricAlgebra: subscript\n\njulia> GeometricAlgebra.show_basis_blade(io, sig, indices) = print(io, join(\"𝒆\".*subscript.(indices), \"∧\"))\n\njulia> prod(basis(4))\nBasisBlade{⟨++++⟩, 4, Int64} of grade 4:\n 1 𝒆₁∧𝒆₂∧𝒆₃∧𝒆₄\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_signature-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.show_signature","text":"show_signature(io, sig)\n\nPretty-print the metric signature sig.\n\nThis is used to display the metric signature type parameter in AbstractMultivector subtypes to reduce visual noise. Methods may optionally be added for user-defined metric signatures, in a similar fashion to Base.show.\n\nExamples\n\njulia> sig = (+1,-1,-1,-1)\n(1, -1, -1, -1)\n\njulia> GeometricAlgebra.show_signature(stdout, sig)\n⟨+---⟩\n\njulia> BasisBlade{sig}\nBasisBlade{⟨+---⟩} (pretty-printed BasisBlade{(1, -1, -1, -1)})\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.@basis-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.@basis","text":"@basis sig\n\nPopulate namespace with basis blades of every grade in the geometric algebra with metric signature sig.\n\nwarning: Warning\nThis defines 2^n variables for an n dimensional signature.\n\nSee also @basisall.\n\nExamples\n\njulia> @basis 3\n[ Info: Defined basis blades v, v1, v2, v3, v12, v13, v23, v123\n\njulia> 1v2 + 3v12\n8-component Multivector{3, 0:3, Vector{Int64}}:\n 1 v2\n 3 v12\n\n\n\n\n\n","category":"macro"},{"location":"reference/#GeometricAlgebra.@basisall-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.@basisall","text":"@basisall sig\n\nSimilarly to @basis, populate namespace with basis blades, but include all permutations of each blade (e.g., v21 as well as v12).\n\nwarning: Warning\nThis defines more than 2^n variables for an n dimensional signature!\n\nExamples\n\njulia> @basisall (+1,-1)\n[ Info: Defined basis blades v, v1, v2, v12, v21\n\njulia> v12 == -v21\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Internals","page":"Reference","title":"Internals","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"bits.jl\", \"show.jl\", \"generated.jl\"]\nModules = [GeometricAlgebra]","category":"page"},{"location":"reference/#GeometricAlgebra.BitPermutations","page":"Reference","title":"GeometricAlgebra.BitPermutations","text":"BitPermutations{T}(n)\n\nInfinite iterator returning all unsigned integers of type T, in ascending order, for which Base.count_ones is n.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GeometricAlgebra.bits_of_grade-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.bits_of_grade","text":"bits_of_grade(k[, dim])\n\nGenerate basis blade bits of grade k in ascending order. Yields all basis blades in the dimension dim, if given, otherwise iterates indefinitely.\n\nExamples\n\njulia> GeometricAlgebra.bits_of_grade(2, 4) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.bits_to_indices-Tuple{Unsigned}","page":"Reference","title":"GeometricAlgebra.bits_to_indices","text":"bits_to_indices(bits)\n\nReturn the positions of the ones in the unsigned integer bits.\n\nUsed to convert between representations of a unit blade. Inverse of indices_to_bits.\n\nExamples\n\njulia> GeometricAlgebra.bits_to_indices(0b1001101)\n4-element Vector{Int64}:\n 1\n 3\n 4\n 7\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.componentbits-Tuple{Any, Any}","page":"Reference","title":"GeometricAlgebra.componentbits","text":"componentbits(n, k)\ncomponentbits(::Val{N}, ::Val{K})\n\nVector of bits corresponding to components of an n-dimensional Multivector of grade(s) k.\n\nBits are ordered first by grade (count_ones), then lexicographically (in ascending numerical order).\n\nPassing Val arguments calls a faster, memoized method.\n\nExamples\n\njulia> componentbits(4, 2) .|> UInt8 .|> bitstring\n6-element Vector{String}:\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00001001\"\n \"00001010\"\n \"00001100\"\n\njulia> componentbits(3, 0:3) .|> UInt8 .|> bitstring\n8-element Vector{String}:\n \"00000000\"\n \"00000001\"\n \"00000010\"\n \"00000100\"\n \"00000011\"\n \"00000101\"\n \"00000110\"\n \"00000111\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.factor_from_squares-Tuple{Any, Unsigned}","page":"Reference","title":"GeometricAlgebra.factor_from_squares","text":"factor_from_squares(sig, bits::Unsigned)\n\nCompute the overall factor arising from the geometric product between repeated basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.geometric_prod_bits-Tuple{Any, Unsigned, Unsigned}","page":"Reference","title":"GeometricAlgebra.geometric_prod_bits","text":"geometric_prod_bits(sig, a::Unsigned, b::Unsigned)\n\nCompute the geometric product between unit blades. Returns a tuple of the overall scalar factor and the resulting unit blade.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.indices_to_bits","page":"Reference","title":"GeometricAlgebra.indices_to_bits","text":"indices_to_bits(indices, T=UInt)\n\nCreate unsigned integer with bits at the positions given in the vector indices.\n\nUsed to convert between representations of a unit blade. Inverse of bits_to_indices.\n\nwarning: Warning\nOnly correct if maximum(indices) does not exceed number of bits in T.\n\nExamples\n\njulia> GeometricAlgebra.indices_to_bits([1, 2, 5], UInt8) |> bitstring\n\"00010011\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#GeometricAlgebra.next_bit_permutation-Tuple{Unsigned}","page":"Reference","title":"GeometricAlgebra.next_bit_permutation","text":"Return the smallest uint larger than the one given which has the same number of binary ones. Algorithm is Gosper’s hack.\n\nExamples\n\njulia> GeometricAlgebra.next_bit_permutation(0b1011) |> bitstring\n\"00001101\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.reversion_sign-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.reversion_sign","text":"reversion_sign(k) = mod(k, 4) <= 1 ? +1 : -1\n\nSign from reversing a k-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.sign_from_swaps-Tuple{Unsigned, Unsigned}","page":"Reference","title":"GeometricAlgebra.sign_from_swaps","text":"sign_from_swaps(a::Unsigned, b::Unsigned)\n\nCompute sign flips of blade product due to transposing basis vectors into sorted order. (The full sign of the product will also depend on the basis norms.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_blade-Tuple{IO, BasisBlade}","page":"Reference","title":"GeometricAlgebra.show_blade","text":"Display blade with parentheses surrounding coefficient if necessary.\n\njulia> GeometricAlgebra.show_blade(stdout, BasisBlade{(x=1,)}(0b1 => 1 + im))\n(1+1im) x\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.show_multivector-Tuple{IO, Any}","page":"Reference","title":"GeometricAlgebra.show_multivector","text":"Display multivector components in in a column or inline, optionally grouping by grade.\n\nParameters:\n\ninline::Bool: print on one line (default true)\ngroupgrades::Bool: visually group components by grade (default true).  If inline, draws parentheses around parts of each grade; if multiline, draw  each grade on its own line\nshowzeros::Bool: whether to omit zero components from display\nindent::Integer: indent amount\n\njulia> a = Multivector{2,0:2}((1:4) .^ 2);\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=false)\n 1 v\n 4 v1\n 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=false, groupgrades=true)\n1\n4 v1 + 9 v2\n16 v12\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=true)\n(1) + (4 v1 + 9 v2) + (16 v12)\n\njulia> GeometricAlgebra.show_multivector(stdout, a; inline=true, groupgrades=false)\n1 + 4 v1 + 9 v2 + 16 v12\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.symbolic_optim-Union{Tuple{Sig}, Tuple{Any, Vararg{Union{Type{var\"#s24\"}, var\"#s24\"} where var\"#s24\"<:AbstractMultivector{Sig}}}} where Sig","page":"Reference","title":"GeometricAlgebra.symbolic_optim","text":"symbolic_optim(f, a, b, ...)\n\nTrace evaluation of f(a, b, ...)::CompositeMultivector on symbolic versions of each AbstractMultivector instance or type a, b, ..., returning an expression suitable as the body of a @generated function.\n\nimportant: Important\nThe names of the generated function arguments must be \"a\", \"b\", \"c\", etc, as these are the names used in the expression retuned by symbolic_optim.\n\nIf use_symbolic_optim(sig) returns false, the function body simply calls f(a, b, ...).\n\nExamples\n\nusing MacroTools: prettify\nu, v = Multivector.(basis(2))\nex = GeometricAlgebra.symbolic_optim(*, u, v) |> prettify\n\n# output\n:(let a = components(a), b = components(b)\n      comps = create_array(Vector{Any}, Int64, Val{1}(), Val{(2,)}(), a[1] * b[1] + a[2] * b[2], a[1] * b[2] + (-1 * a[2]) * b[1])\n      (Multivector{2, 0:2:2})(comps)\n  end)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GeometricAlgebra.use_symbolic_optim-Tuple{Any}","page":"Reference","title":"GeometricAlgebra.use_symbolic_optim","text":"use_symbolic_optim(sig) -> Bool\n\nWhether to use symbolic code generation to optimize operations in algebras of metric signature sig.\n\nBy default, this is enabled if dimension(sig) ≤ 8 as a heuristic (in many dimensions, algebraic expressions may become too unwieldy).\n\n\n\n\n\n","category":"method"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"CurrentModule = GeometricAlgebra\nDocTestSetup = quote\n\tusing GeometricAlgebra\nend","category":"page"},{"location":"#GeometricAlgebra","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"","category":"section"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"GeometricAlgebra.jl implements flexible types for working with geometric (or Clifford) algebras.","category":"page"},{"location":"#Quick-Start","page":"GeometricAlgebra","title":"Quick Start","text":"","category":"section"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Construct multivectors by providing a metric signature and grade as type parameters:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> using GeometricAlgebra\n\njulia> u = Multivector{3,1}([1, -1, 0]) # 3D Euclidean vector\n3-component Multivector{3, 1, Vector{Int64}}:\n  1 v1\n -1 v2\n  0 v3","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Non-euclidean metric signatures may be specified:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> v = Multivector{(-1,1,1,1),2}(1:6) # Lorentzian bivector\n6-component Multivector{⟨-+++⟩, 2, UnitRange{Int64}}:\n 1 v12\n 2 v13\n 3 v23\n 4 v14\n 5 v24\n 6 v34\n\njulia> exp(v)\n8-component Multivector{⟨-+++⟩, 0:2:4, Vector{Float64}}:\n 1.18046\n 0.818185 v12 + -0.141944 v13 + 0.153208 v23 + 1.076 v14 + 1.16194 v24 + 1.03866 v34\n 0.999268 v1234","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Notice that this bivector exponential has grades 0:2:4. The grade parameter K of a Multivector{Sig,K} can be a single integer (for homogeneous multivectors) or a collection of grades. A general 4D multivector has grades 0:4, but an even multivector may be more efficiently represented with grades 0:2:4.","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"You may also obtain an orthonormal basis for a metric signature:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> v = basis(3)\n3-element Vector{BasisBlade{3, 1, Int64}}:\n v1\n v2\n v3\n\njulia> exp(10000*2π*v[2]v[3])\n4-component Multivector{3, 0:2:2, Vector{Float64}}:\n 1.0\n -9.71365e-13 v23","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"Macros are provided for interactive use:","category":"page"},{"location":"","page":"GeometricAlgebra","title":"GeometricAlgebra","text":"julia> @basis \"+---\"\n[ Info: Defined basis blades v, v1, v2, v3, v4, v12, v13, v14, v23, v24, v34, v123, v124, v134, v234, v1234\n\njulia> @basisall (t = +1, x = -1)\n[ Info: Defined basis blades t, x, tx, xt","category":"page"}]
}
