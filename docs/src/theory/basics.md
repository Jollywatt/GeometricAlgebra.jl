```@meta
CurrentModule = GeometricAlgebra
DocTestSetup = quote
	using GeometricAlgebra
end
```

```@setup ga
using GeometricAlgebra
```

# Introduction

This is a brief overview of the mathematics of geometric algebra, using `GeometricAlgebra.jl` to explain features along the way.


## Definition

[Geometric algebra](https://en.wikipedia.org/wiki/Geometric_algebra) is what you get when vectors in a space are allowed to be multiplied _freely_,[^1] with the rule that a vector ``ğ’–`` multiplied by itself gives its scalar dot product, ``ğ’–^2 = ğ’–â‹…ğ’–``.
What do you get when you multiply two different vectors?
Well, we can simplify expressions using the relation ``ğ’–^2 = ğ’–â‹…ğ’–``, along with the usual associativity ``ğ’–(ğ’—ğ’˜) = (ğ’–ğ’—)ğ’˜`` and distributivity ``(ğ’– + ğ’—)ğ’˜ = ğ’–ğ’˜ + ğ’—ğ’˜``, but we may still be left with irreducible products, ``ğ’–ğ’—``.
These are a _new kind of object_, distinct from scalars or vectors. These objects are called **multivectors**.

[^1]: More formally, ``Cl(V, â‹…)`` is the _freest_ unital associative algebra generated by ``V`` satisfying ``ğ’–^2 = ğ’–â‹…ğ’–`` for all ``ğ’– âˆˆ V``.

What this means becomes clearer after choosing a basis. In geometric algebras, orthonormal vectors ``ğ¯_1, ..., ğ¯_n âˆˆ V`` multiply according to the rules[^2]
- ``ğ¯_i^2 = ğ¯_iâ‹…ğ¯_i``,
- ``ğ¯_iğ¯_j = -ğ¯_jğ¯_i`` where ``i â‰  j``.
The basis vector _norms_ ``ğ¯_iâ‹…ğ¯_i`` may be ``+1``, ``-1`` or ``0`` depending on the [inner product](https://en.wikipedia.org/wiki/Inner_product_space) ``â‹…`` on ``V``.
The elements ``ğ¯_iğ¯_j`` are [**bivectors**](https://en.wikipedia.org/wiki/Bivector) (a kind of oriented plane-element), and higher grade terms ``ğ¯_iğ¯_jğ¯_k`` are **trivectors**, etc.

[^2]: The second rule is implied by the first, which is the defining relation ``ğ’–^2 = ğ’–â‹…ğ’–``.

In code, we may obtain an orthonormal basis with [`basis(sig)`](@ref), where `sig` is the [metric signature parameter](@ref sig).
We may also introduce basis variables into the global namespace with
```@repl ga
@basis 3
v1^2 # vector square gives its norm
v2*v1 # orthogonal vectors anticommute
```

!!! note "Terminology"
	Geometric algebras are also called (real) [Clifford algebras](https://en.wikipedia.org/wiki/Clifford_algebra) and are denoted ``Cl(V, â‹…)`` or ``Cl(V, Q)``, where ``â‹…`` has the [associated quadratic form](https://en.wikipedia.org/wiki/Bilinear_form#Derived_quadratic_form) ``Q``.

	Denote by ``Cl(n)`` the algebra over ``â„^n`` where ``â‹…`` is the standard Euclidean dot product.
	Write ``Cl(p,q)`` for ``V = â„^{p + q}`` where the inner product has ``p`` orthonormal basis vectors with norm ``+1`` and ``q`` with norm ``-1``, and ``Cl(p,q,r)`` if there are an additional ``r`` basis vectors which square to zero.

!!! note "Formal definition"
	A formal construction of the geometric algebra ``Cl(V, â‹…)`` over a vector space ``V`` with inner product ``â‹…`` is as the [quotient algebra](https://en.wikipedia.org/wiki/Quotient_ring#For_algebras_over_a_ring) `` Cl(V, â‹…) â‰… V^âŠ— \big/ I ``. Here, the tensor algebra ``V^âŠ— = â„ âŠ• V âŠ• (V âŠ— V) âŠ• â‹¯`` is reduced by the [ideal](https://en.wikipedia.org/wiki/Ideal_(ring_theory)) ``I`` which identifies all elements of the form ``ğ’– âŠ— ğ’– - ğ’–â‹…ğ’–`` where ``ğ’– âˆˆ V`` with zero.
	The result is a vector space isomorphic to the exterior algebra ``âˆ§V`` but with an algebraic product which mixes degrees.


## Graded structure

Geometric algebras have a _graded structure_: every element has a grade ``k âˆˆ \{0, 1, 2..., n\}`` or is a sum of elements of differing grades.
As a vector space, ``Cl(V, â‹…)`` is the direct sum of fixed-grade subspaces
```math
Cl(V, â‹…) = â¨_{k=0}^n âˆ§^n V = â„ âŠ• V âŠ• âˆ§^2 V âŠ• â‹¯ âŠ• âˆ§^n V
```
where ``âˆ§^k V`` is the ``k``th exterior power of the ``n``-dimensional base space ``V``.

Grade zero elements (``âˆ§^0V = â„``) are scalars; grade one elements (``âˆ§^1V = V``) are vectors; and grade-``k`` elements (``âˆ§^k V``) are called **``k``-vectors** or **homogeneous multivectors**.
Elements of ``Cl(V, â‹…)`` may consist of parts of differing grade, and when they do they are called **(inhomogeneous) multivectors**.

### Grade projection

There are no non-zero ``k``-vectors outside the range ``0 â‰¤ k â‰¤ n``, so the subspace of ``âˆ§^nV`` contains the highest-grade objects, called **pseudoscalars**.

Grade | Dimension of subspace | Name
:----:|:---------:|:----
``0`` | ``1`` | scalars
``1`` | ``n`` | vectors
``2`` | ``\binom{n}{2}`` | bivectors
``3`` | ``\binom{n}{3}`` | trivectors
``â‹®`` | ``â‹®`` | ``â‹®``
``k`` | ``\binom{n}{k}`` | ``k``-vectors
``â‹®`` | ``â‹®`` | ``â‹®``
``n - 1`` | ``n`` | pseudovectors
``n`` | ``1`` | pseudoscalars
all | ``2^n`` | multivectors

Notice that subspaces of grade ``k`` and ``n - k`` have the same dimension.
Subspaces ``âˆ§^kV`` and their â€œpseudoâ€-prefixed counterparts ``âˆ§^{n - k}V`` are associated through [duality](dualities.md).

If ``A âˆˆ Cl(V, â‹…)`` is a multivector, then denote its grade ``k`` part as
```math
âŸ¨AâŸ©_k âˆˆ âˆ§^kV
\quad\text{(grade projection)}
```
In code, grade projection is achieved with `grade(A, k)`:
```@repl ga
A = Multivector{4,0:4}(rand(-10:10, 2^4))
grade(A, 3)
```

## Blades and multivectors

A general element in a geometric algebra is called a **multivector**, though there is a hierarchy of specific kinds:

```math
\textsf{basis blades} âŠ‚
\textsf{blades} âŠ‚
\textsf{$k$-vectors} âŠ‚
\textsf{multivectors}
```


### Basis blades

Let ``ğ¯_1, ..., ğ¯_n`` be the standard orthonormal basis vectors with ``ğ¯_iâ‹…ğ¯_i âˆˆ \{+1,0,-1\}`` and ``ğ¯_iâ‹…ğ¯_j = 0`` for ``i â‰  j``.
Products of the form
```math
ğ¯_{i_1}ğ¯_{i_2}â‹¯ğ¯_{i_k}
```
where ``i_1 < â‹¯ < i_k`` are the standard **basis blades**. Reordering the product only introduces overall factors of ``Â±1``, flipping the **orientation** of the blade.


Scalar multiples of basis blades are represented with the `BasisBlade{Sig,K,T}` type, which encodes indices ``i_1, ..., i_k`` as binary-ones. (See [`bits_to_indices`](@ref) and [`indices_to_bits`](@ref).)
```@repl ga
BasisBlade{4}(42, 0b1011)
```
You can generate all basis blades (of a given grade) for an algebra with [`basis()`](@ref).
```@repl ga
basis(Cl(3,1), 2) # 4-dimensional Lorentzian 2-blades
```

Basis blades are stored with canonically sorted indices. For example, ``ğ¯_2ğ¯_1`` is represented as ``-ğ¯_1ğ¯_2``:
```@repl ga
@basis 2 allperms=true
v21
```
While this is always the way blades are represented internally, how they are _displayed_ can be customised through a [`BasisDisplayStyle`](@ref).


#### Multiplication of basis blades

Basis blades are closed under multiplication: a product of basis blades is a basis blade. (This motivates them having their own `BasisBlade` type.)


The geometric product of ``ğ¯_I â‰¡ ğ¯_{i_1}ğ¯_{i_2}â‹¯ğ¯_{i_p}`` and ``ğ¯_J â‰¡ ğ¯_{j_1}ğ¯_{j_2}â‹¯ğ¯_{j_q}`` can be put into canonical form it two steps:
1. Sort the basis vectors into ``ğ¯_{k_1}ğ¯_{k_2}â‹¯ğ¯_{k_{p+q}}`` where ``k_1 â‰¤ â‹¯ â‰¤ k_{p + q}``. Each transposition of adjacent, distinct vectors results in an overall factor of ``-1``. 
2. Simplify adjacent repeated vectors using the fact that ``ğ’—^2 = ğ’—â‹…ğ’—`` is a scalar.

Mathematically, this is
```math
ğ¯_Iğ¯_J =
	\underbrace{\left(\sum_{k âˆˆ I âˆ© J} ğ¯_k^2\right)}_{\text{factor from squares}}
	\underbrace{\operatorname{sign}(\operatorname{sortperm}(I âŠ» J))}_{\text{sign from swaps}}
	\; ğ¯_{I âŠ» J}
```
where ``I âˆ© J`` are the shared indices and ``I âŠ» J`` is the symmetric difference (the indices present in only one blade). In multi-index notation, ``ğ¯_{I âŠ» J} â‰¡ ğ¯_{k_1}ğ¯_{k_2}â‹¯ğ¯_{k_m}`` where ``I âŠ» J = \{k_1, ..., k_m\}``. ``\operatorname{sortperm}(I)`` is the permutation that puts the indices ``I`` in ascending order.

You can print a basis blade multiplication table using [`cayleytable`](@ref):
```@repl ga
cayleytable(3)
```


### Blades

While a _basis_ blade is a product of orthogonal _basis_ vectors, the mathematical definition of a **``k``-blade** is a product of ``k`` distinct, mutually orthogonal vectors â€” or equivalently, a ``k``-blade is a ``âˆ§``-product of ``k`` linearly independent vectors.

Not all blades are representable as basis blades in a given choice of basis. For example, in ``Cl(3)`` the product ``ğ¯_1(ğ¯_2 + ğ¯_3)`` is a blade (since ``ğ¯_1`` and ``ğ¯_2 + ğ¯_3`` are orthogonal vectors), but it is a sum of two basis blades, ``ğ¯_1ğ¯_2 + ğ¯_1ğ¯_3``.

Thus, we cannot represent all blades with the `BasisBlade` type.
Instead, we may use the more general `Multivector` type:
```@repl ga
@basis 3
v1*(v2 + v3) # a blade, but not a basis blade
```

### Multivectors

A sum of ``k``-blades is a ``k``-vector, or **homogeneous multivector**.
A sum of blades of differing grade is an **inhomogeneous multivector**.
We may use terminology such as â€œ``\{0,3\}``-vectorâ€ to mean an inhomogeneous multivector with both scalar and trivector parts.

The `Multivector{Sig,K}` type represents a `K`-vector, which may be homogeneous (if `K` is an integer) or inhomogeneous (if `K` is a collection, such as `(0, 3)` or `0:3`). 
In all cases, the underlying data is stored in a single vector, while the type parameters define the interpretation.

```@repl ga
@basis 3
4 + 7I # scalar + pseudoscalar; a (0, 3)-vector
ans.comps # underlying components vector
1 + 2v1 + 3v23 # a general multivector
ans.comps
```


!!! note
	(Pseudo)scalars and (pseudo)vectors are always blades, but not all ``k``-vectors are ``k``-blades.
	The simplest example of a homogeneous multivector which isnâ€™t a blade requires four dimensions: the bivector ``ğ¯_1ğ¯_2 + ğ¯_3ğ¯_4`` is not a blade since it cannot be factored as ``ğ’–âˆ§ğ’—`` for vectors ``ğ’–`` and ``ğ’—``.


